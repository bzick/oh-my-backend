Oh My BackEnd
=============

**Что это?** Этот документ содержит список (roadmap) навыков, которые **часто** требуются backend разработчику web-приложений. Документ разделён на этапы (темы), каждый этап разделён на пункты. Каждый пункт, в документе, подразумевает что:
- бекендер знает что это и какую проблему решает.
- бекендер знает для чего и когда следует применить.
- бекендер знает как с этим работать или знает где подсмотреть.
- при разработке или проектировании бекендер помнит про них и учитывает в приложении.

Принцип работы пункта будет дополнительным бонусом в понимании темы, но это может занять много времени. Изучайте по желанию и необходимости.

**Как работать с документом?** Этапы и пункты выстроены в рекомендуемом порядке для изучения. Просто следуйте сверху-вниз.

**Как работать с пунктами документа?** Каждый пункт легко гуглится и имеет страницу в wikipedia. 
Ссылки устанавливаются если есть альтернативная документация — более понятная и/или более подробная.
Ссылка на вики ставятся что бы исключить ошибочного варианта статьи на вики.
> Цитатой обозначены пояснения к пункту для чего следует это знать и/или где с этим можно столкнуться. 
> Если пояснения нет — то либо не успели сделать, либо там и так ясно.

**Есть-ли разделение по скилам?** Каждый пункт делится на градации <kbd>junior</kbd>, <kbd>middle</kbd>, <kbd>middle+</kbd> (он же <kbd>high middle</kbd>). 
Градация используются что бы помочь разделить кучу тем на то что стоит изучать в первую очередь. 
Тут применяется [общепринятая градация](https://vas3k.ru/blog/team/) навыков и зон ответственности, где <kbd>senior</kbd> это <kbd>middle+</kbd> с soft-скилами.
Поэтому тут будет максимум <kbd>middle+</kbd>, так как документ про hard-скилы.

Метка <kbd>guru ⚡</kbd> означает что этот пункт для более глубокого и продвинутого изучения темы (если у Вас есть время).

**В каком состоянии документ?** Документ еще находится в процессе дополнения. 
В идеале каждый пункт должен иметь градацию, иметь пояснение и иметь ссылку на толковое разъяснение на русском языке. 
До идеала еще далеко, но начало положено!

Если хотите что-то изменить (пункт, ссылку, опечатку) — создавайте [issue](https://github.com/bzick/oh-my-backend/issues) или делайте [pr](https://github.com/bzick/oh-my-backend/pulls). 
Если хотите обсудить документ — создавайте обсуждение в [discussions](https://github.com/bzick/oh-my-backend/discussions).

# Содержание

* [Этап 1. Виртуализация docker](#этап-1-виртуализация-docker)
* [Этап 2. Linux](#этап-2-linux)
* [Этап 3. Общие знания](#этап-3-общие-знания)
* [Этап 4. Сеть](#этап-4-сеть)
* [Этап 5. Базы данных](#этап-5-базы-данных)
* [Этап 6. Протокол HTTP](#этап-6-протокол-http)
* [Этап 7. Безопасность](#этап-7-безопасность)
* **[Этап 8. Тут должен быть ваш язык программирования](#этап-8-тут-должен-быть-ваш-язык-программирования)**
* [Этап 9. Электронная почта](#этап-9-электронная-почта)
* [Этап 10. Полнотекстовый поиск](#этап-10-полнотекстовый-поиск)
* [Этап 11. Логи и метрики](#этап-11-логи-и-метрики)
* [Этап 12. Проектирование](#этап-12-проектирование-и-разработка)

# Этап 1. Виртуализация docker

Для начала надо поднять виртуальную машину для экспериментов и исследований.
Даже если уже имеете Linux на рабочей машине, всё равно поднимите виртуализацию. В случае чего, виртуальную машину всегда можно пересоздать.
Есть много систем виртуализаций, но docker выделяется среди них. Он один из популярных десктопных виртуализаций и близок с Kubernetes (aka k8s) - популярной серверной виртуализацией.

1. установить [docker](https://www.docker.com/products/docker-desktop) <kbd>junior</kbd>
1. запустить контейнер с Linux Ubuntu, последней [LTS версией](https://ru.wikipedia.org/wiki/Список_версий_Ubuntu#История_выпусков). Запустить bash (консоль) контейнера. <kbd>junior</kbd>
1. установить удобное приложение для управления образами и контейнерами [Kitematic](https://kitematic.com/), [Portainer](https://hub.docker.com/r/portainer/portainer/) и тд. 
   Либо сродниться с консольными командами docker. На некоторых OC десктопный docker уже имеет [свой dashboard](https://docs.docker.com/desktop/dashboard/) для управления образами и контейнерами. <kbd>junior</kbd>
1. docker compose для поднятия кластера контейнеров. <kbd>middle</kbd>
   > Для рабочего приложения, как правило, требуется несколько различных сервисов (база данных, кешер, http сервер и тд)
   > и всё это запихать в один docker контейнер будет проблемно, просто из-за специфики работы самого docker-а.
   > Тут как раз поможет compose что бы запустить кучу контейнеров и подружить их между собой.

# Этап 2. Linux

Изучить установленный в контейнере Linux. Linux, де-факто, является серверной ОС для большинства web-приложений. 
В этом разделе будет говориться о linux, хотя (почти) всё так же актуально и для других posix-совместимых систем. Например для [bsd семейства](https://ru.wikipedia.org/wiki/BSD), включая macos. Однако, могут быть отличия. 
В качестве стартового linux, обычно, выбирают [Ubuntu](https://ru.wikipedia.org/wiki/Ubuntu), но можете взять самый компактный linux - [Alpine](https://ru.wikipedia.org/wiki/Alpine_Linux), который часто используется в виртаулизации.

1. Установка пакетов и обновление системы через `apt`/`apt-get` у Ubuntu/Debian и `apk` у alpine. <kbd>junior</kbd>
   > В процессе исследований и различных проб придётся много раз ставить, обновлять и переустанавливать множество пакетов linux.
   > Лучше сразу изучить как работают эти команды. Нужны бызовые операции: найти, установить, обновить, удалить.
1. Базовые навыки в `bash` (улучшенный `sh` aka `shell`). <kbd>junior</kbd>
   > В linux-подобных системах башом пронизано всё, вы гарантировано столкнётесь с ним и будут случаи когда надо будет писать bash/shell скрипты.
   * Базовый синтаксис bash. <kbd>middle</kbd>
     > По факту это единственный скриптовый язык который гарантированно будет установлен в системе.
     * Управляющие операторы `if`, `for` и `while`
     * Логические операторы `;`, `&&`, `||`
     * Исполняющие выражения `` `cmd` `` и `$(cmd)`
   * Базовые команды для работы с файловой системой `cd`, `ls`, `find`, `cat`, `cp`, `mv`, `mkdir`, `rmdir`, `rm`. <kbd>junior</kbd>
   * Вызов мануалов через команду `man`. <kbd>junior</kbd>
     > Через эту команду можно получить справку по любой команде, операции, файлам и даже исходному коду.
   * Конвейеры команд через оператор `|` (`cmd1 | cmd2 | cmd3`). <kbd>junior</kbd>
     > Linux большое количество команд для обработки данных и для решения различных задач придётся их объединять через конвейеры.
   * Команды обработки данных `cat`, `tail`, `head`, `grep`, `awk`, `sed`. <kbd>middle</kbd>
     > Этот набор потребуется для сканирования и анализа логов или больших объёмов текстовых данных.
   * Команды работы с архивами данных `zcat`, `gzip`, `gunzip`, `tar`, `zgrep`. <kbd>middle</kbd>
     > Как правило, никто не хранит логи или большие объёмы текстовых данных как есть, обычно это архив `gz` или `tar.gz` (`tgz`).
   * [Консольные редакторы vim, nano.](https://gitlab.com/doatta/gnu-linux-rhcsa/-/blob/master/10.%20Текстовые%20редакторы%20nano%20и%20vi.md) Открыть файл, внести изменения, сохранить. <kbd>junior</kbd>
     > Редактирование файла из консоли не такая редкость. Кстати, что бы выйти из vim: esc, напечатайте `:q!`, enter.
   * Консольные просмотрщики `less`, `zless`. Открыть, найти слово, закрыть. <kbd>junior</kbd>
     > Редакторы избыточны, что бы просто посмотреть содержимое файла. Просмотрщики так же справляется с не "стандартными" для редакторов файлами.
   * Фоновые задачи, оператор `&`, команды `jobs`, `fg`, `bg`. <kbd>middle</kbd>
     > Оператор позволит в одной shell сессии запускать несколько команд.
   * Команда игнорирования сигналов прерываний `nohup`. <kbd>middle</kbd>
     > Команда позволит, при завершении shell сессии, оставлять в живых запущенные фоновые задачи до их логического завершения.
   * [Потоки, перенаправление потоков](http://gitlab.com/doatta/gnu-linux-rhcsa/-/blob/master/11.%20Стандартные%20потоки.md), операторы `>`, `>>`, `<`. <kbd>junior</kbd>
     > Куда писать вывод, а куда ошибки помогут указать эти операции.
   * [Упороться полность консолью](https://github.com/jlevy/the-art-of-command-line/blob/master/README-ru.md) <kbd>guru ⚡</kbd>
1. Понятие `процесс`. <kbd>junior</kbd>
   > Как и во всех других ОС linux запущенные приложения представляются процессами.
   * Команды анализа процессов `top`, `htop`, `ps` (`ps aux`). <kbd>junior</kbd>
     > Этакий "диспетчер задач" в мире linux, позволяющий мониторить процессы системы.
   * Родительский процесс, дочерний процесс. <kbd>middle</kbd>
     > Процессы не появляются из ниоткуда, их что-то запускает. Понимание иерархии процессов облегчит работу с ними и сделает проще понимание мультипроцессовых приложений.
   * Мастер-воркер процессы, демон (daemon). <kbd>middle</kbd>
     > Это один из распространённых видов распараллеливания вычислений в приложениях. Много программ используют именно такой подход распараллеливания.
   * Зомби-процессы, откуда берутся, как с ними бороться. <kbd>middle+</kbd>
     > Это вид проблемы распараллеливания вычислений через дочерние процессы. Возникает когда у мастер-процесса есть проблемы или баги.
   * [Отправка сигналов процессам](https://ru.wikipedia.org/wiki/Сигнал_(Unix)). <kbd>junior</kbd>
     > Это основной рычаг воздействия на процессы сторонними приложениями (системными или вашими).
       * Изучение команд `kill`, `pkill`, `killall`. <kbd>junior</kbd>
       * Назначение сигналов [SIGKILL](https://ru.wikipedia.org/wiki/SIGKILL), [SIGTERM](https://ru.wikipedia.org/wiki/SIGTERM), [SIGINT](https://ru.wikipedia.org/wiki/SIGTERM), [SIGHUP](https://ru.wikipedia.org/wiki/SIGHUP), [SIGSEGV](https://ru.wikipedia.org/wiki/SIGSEGV). <kbd>middle</kbd>
   * Системный вызов (syscall). <kbd>middle+</kbd>
     > Системный вызов (вызов API ядра linux) — не бесплатная операция и лучше их держать под контролем на высоконагруженных приложениях.
   * Команда анализа системных вызов процесса через `strace`. <kbd>middle+</kbd>
     > Самый простой и доступный способ посмотреть какие системные вызовы делает процесс в реальном времени.
1. Изучение понятия `дескриптор`. <kbd>middle</kbd>
   > Любой поток данных (входящий и/или исходящий) представляется в виде дескрипторов. Что-либо читать или писать будете (вероятней всего) через дескриптор.
   * Стандартные дескрипторы `STDIN`, `STDOUT`, `STDERR` и их нумерация. <kbd>middle</kbd>
     > Любой поток в процессе пронумерован и есть "зарезервированные" номера под определенные потоки.
   * Потоки, сокеты и unix-сокеты. <kbd>middle</kbd>
     > Это всё разновидности дескрипторов с которыми придётся работать. На всех них распространяются правила дескрипторов, ну так как они и есть дескрипторы.
   * Ограничение на дескрипторы. <kbd>middle+</kbd>
     > Не редкая проблема приложений когда оно упирается в лимит открытых дескрипторов.
   * Команда анализа открытых дескрипторов у процесса через `lsof`. <kbd>middle+</kbd>
     > Для отладки приложения всегда надо знать с чем ведёт общение приложение (отлично работает в паре с `strace`, сопоставляя номера дескрипторов).
1. [Пользователи](https://gitlab.com/doatta/gnu-linux-rhcsa/-/blob/master/19.%20Пользователи.md) <kbd>junior</kbd>
   * Пользователь `root`. <kbd>junior</kbd>
   * Супер пользователь, команды [su](https://gitlab.com/doatta/gnu-linux-rhcsa/-/blob/master/17.%20su.md) и [sudo](https://gitlab.com/doatta/gnu-linux-rhcsa/-/blob/master/18.%20sudo.md). <kbd>junior</kbd>
     > Никто не даст вам root на проде, но вполне можете иметь "привилегированного" пользователя, который умеет в `sudo`.
1. [Файловая система](https://gitlab.com/doatta/gnu-linux-rhcsa/-/blob/master/04.%20%D0%9E%20%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D1%8B%D1%85%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0%D1%85.md) <kbd>junior</kbd>
   * Команда `stat`  <kbd>junior</kbd>
   * [Права и доступы файловой системы](https://gitlab.com/doatta/gnu-linux-rhcsa/-/blob/master/20.%20Права%20на%20файлы.md) <kbd>junior</kbd>
     > Избыточные доступы ведут к дыре в безопасности, недостаток доступов ведёт к багам в приложении. Осмысленно ставьте где `x` (особенно у директорий), где `r`, а где `w`.
   * Понимание описания доступов вида `--xr-xrwx` и `0137` (восьмеричная) у файлов и директорий. <kbd>junior</kbd>
     > Обычно в таком виде вы будете видеть уровни доступов в консолях.
   * Исполняемые файлы, [sha bang](https://ru.wikipedia.org/wiki/Шебанг_(Unix)). <kbd>junior</kbd>
   * Изменение прав доступов через команды `chmod`, `chown`. <kbd>middle</kbd>
   * [Работа с дисками](https://gitlab.com/doatta/gnu-linux-rhcsa/-/blob/master/22.%20Работа%20с%20дисками.md) <kbd>middle+</kbd>
     > Нужно знать где, как и куда примонтированы различные диски или носители. Бывает что приложение может работает сразу с несколькими дисками, некоторые могут быть сетевыми.
1. Ссылки на файловой системе. <kbd>junior</kbd>
   * Symlink (aka символическая ссылка). <kbd>junior</kbd>
     > Самый распространённый вид ссылки. Повсеместно используется в linux да и пакетных менеджерах разных языков. Вы тоже будете это использовать.
   * Hardlink (aka жесткая ссылка). <kbd>middle</kbd>
     > Редкий случай использования ссылки. Потребуется если надо "дедуплицировать" большой объём файлов.
     > По сути позволяет создать несколько имён одному файлу.
1. Запуск и остановка сервисов systemd. <kbd>middle</kbd>
   > Linux по сути просто пачка запущенных приложений как сервисов.
1. [SSH](https://ru.wikipedia.org/wiki/SSH). <kbd>junior</kbd>
   > Самый доступный способ запустить `shell` на удалённой машине это использовать SSH. Используется повсеместно.
   * Генерация собственного ssh-rsa ключа через `ssh-keygen`. <kbd>junior</kbd>
     > Без него вы не попадёте на хосты по SSH.
   * Использование публичного ssh-rsa ключа для входа на удалённую машину (используйте второй контейнер с linux). <kbd>junior</kbd>
1. Перенос контента. <kbd>junior</kbd>
   > Появляется потребность перекинуть логи, дамп базы и другие файлы между машинами или к себе.
   * `scp` <kbd>junior</kbd>
     > самый простой инструмент переноса файлов между хостами по ssh.
   * `rsync` <kbd>middle</kbd>
     > пожалуй самый мощный инструмент переноса файлов между хостами с кучами настроек, правил и протоколов.
   * `rclone` <kbd>middle</kbd>
     > "rsync" для облачных хранилищ. Универсальный инструмент для работы с контентом, который хранится в облаках или где-то по сети. 
1. Планировщики задач
   * Команда `crontab` и запуск `crond`.
     > Самый распространённый и просто планировщик задач, с весьма гибкими настройками расписания
   * Команда `at` <kbd>middle</kbd>
     > Когда хотите запустить задачу разово к определенному времени.
     > В crontab это потребует отдельно создавать расписание, что сильно затрудняет автоматику и захламляет всё расписание.
1. Оперативная память. <kbd>middle</kbd>
   * Команда `free`, мета информация `/proc/meminfo`. <kbd>middle</kbd>
     > Всегда оценивайте сколько памяти потребуется приложению или скриптам, что бы не быть убитыми системой.
   * Ошибка `Out Of Memory` (OOM) и причина появления. [OOM-киллер](https://habr.com/ru/company/southbridge/blog/464245/). <kbd>middle+</kbd>
     > Именно это происходит когда вы превысили все допустимые пределы потребления памяти в системе.
1. [Логи системы](https://habr.com/ru/post/332502/). Для чего и как посмотреть. <kbd>middle</kbd>
   > Когда случаются проблемы то логи — единственное, что может навести на суть проблемы. 
   > Помимо логов приложения стоит заглядывать в логи системы, иногда её проблема может вести к проблеме в приложениях. Стоит выделить некоторые логи:
   * `dmesg` (driver messages) — важные сообщения от компонентов linux, включая от OOM-киллера. <kbd>middle</kbd>
   * `syslog` — системный журнал. <kbd>middle</kbd>
     > Там могут быть сообщения от ядра Linux, различных служб, сетевых интерфейсов и много другого.
1. Проблемы в linux и последствия. <kbd>junior</kbd>
   > Их много, но выделим только несколько.
   * Kernel panic. <kbd>junior</kbd>
     > BSoD аналог для linux. Самая не приятная ошибка системы, явно намекающая, что система не стабильна.
   * Segmentation fault (aka segfault aka сегфолт). <kbd>middle</kbd>
     > Не такая уж и редкая ошибка приложений, как хотелось бы. Приложение попыталось работать с памятью доступа к которой у неё нет.
   * Core dump (aka корка). <kbd>middle+</kbd>
     > Результат обработки segmentation fault системой. Корка может потребоваться разработчику упавшего приложения для анализа состояния программы на момент падения.

# Этап 3. Общие знания

Некоторые пункты сложно категоризировать в этом документе. Но без них не обойтись. 
Это базовые вещи которые используются повсеместно в коде, в системах, "под капотом" вашего языка программирования.

1. Регулярные выражения. Поиграться регулярными выражениями можно [тут](https://regex101.com/). Хоть каждый язык может иметь своё видение регулярных выражений, в общем смысле (и синтаксисе) они похожи. <kbd>middle</kbd>
   > Рано или поздно придётся спарсить данные из текста или провалидировать данные, вот тут как раз и потребуются регулярные выражения.
1. Криптография. <kbd>junior</kbd>
   > Не пугайтесь. Пункт подразумевает прикладное применение криптографических функций (на кой нужны те или иные функции), а не изучении самой криптографии.
   *  Хеши и хеш функции, в том числе `crc32`, `md5`, `sha1`, `sha256`. <kbd>junior</kbd>
   * Цифровые подписи. <kbd>junior</kbd>
     > Что бы обезопасить от подделки данных используются цифровые подписи этих же данных.
   * Соль для подписей. <kbd>middle</kbd>
     > В теории (да и на практике) хеш функцию можно определить и что бы сильнее обезопасить от "взлома" вашего хеша, использую так называем ую соль.
   * Коллизии хешей. <kbd>middle</kbd>
     > Хеш функции могут на разные данные вернуть один и тот же результат (хеш), что может привести к проблемам и багам.
     > Лучше знать какая вероятность коллизии у хеш функции и как их избегать.
   * Симметричное и асимметричное шифрование. <kbd>middle+</kbd>
     > Иногда приходится шифровать данные и важно выбрать стратегию шифрования.
   * [Принцип работы TLS](https://habr.com/ru/post/188042/). <kbd>middle+</kbd>
     > Имеется ввиду как работаю CA корневые и промежуточные, что стоит за сертификатом.
1. Базовая работа с `git`. <kbd>junior</kbd>
   > По факту это дефолтная система контроля версий в мире IT.
   * Коммит изменений (commit) <kbd>junior</kbd>
   * Отправка изменений (push/pull) <kbd>junior</kbd>
   * Создание веток и тега (branch/tag) <kbd>junior</kbd>
   * Слияние веток (merge) <kbd>junior</kbd>
   * [Упороться полностью git-ом](https://git-scm.com/book/ru/v2)  <kbd>guru ⚡</kbd>
1. Структуры данных. <kbd>junior</kbd>
   * Хеш таблицы. <kbd>middle</kbd>
     > Таблицы часто используются в самих языках программирования (ассоциативные массивы, объекты и тд)
   * Очередь и стек. <kbd>junior</kbd>
     > Самые просты структуры данных, которые часто придётся использовать повседневно в коде.
   * [Связный список](https://ru.wikipedia.org/wiki/Связный_список) и [двусвязный список](https://ru.wikipedia.org/wiki/Связный_список#Двусвязный_список_(двунаправленный_связный_список)). <kbd>middle</kbd>
1. Форматы хранения и передачи данных
   * Текстовые. <kbd>junior</kbd>
     > Текстовые форматы используются так же для хранения конфигурации приложений
     * JSON
     * YAML
     * XML
   * Бинарные. <kbd>middle</kbd>
     > Бинарные форматы используются сугубо для хранения и передачи данных.
     * MessagePack
     * BSON (бинарный аналог JSON)
     * ProtoBuf (бинарный аналог XML)

# Этап 4. Сеть

Сеть в разработке самая важная и, часто, мало заметная часть.

1. Базовое понимание работы сети. <kbd>junior</kbd>
   * Протокол TCP <kbd>middle</kbd>
     > Вы вряд ли будете читать пакеты TCP. Но полезно знать КАК работает TCP,
     > это позволит понять почему при идеальных "интернетах" всё равно приложение может лагать по сети.
     * TCP пакет <kbd>guru ⚡</kbd>
     * Флаги ACK, SYN, FIN и прочие <kbd>middle+</kbd>
     * Буферы (window size) <kbd>middle</kbd>
     * [Проблемы TCP](https://www.youtube.com/watch?v=aXYJlizk3CQ) <kbd>middle+</kbd>
       > TCP очень старый протокол, который не удовлетворяет реалиям.
       > На видео изобретают свой UDP протокол, рассматривая проблемы TCP и решая их в UDP.
   * Протокол UDP. <kbd>middle</kbd>
     > Самый простой сетевой протокол семейства. Требуется понимание его работы.
     > HTTP/3.0, DNS работает на протоколе UDP, и понимание UDP даст немного понимания в работе HTTP/3.0
     * UDP пакет <kbd>guru ⚡</kbd>
1. Проблемы сети. <kbd>junior</kbd>
   > Их, как всегда, много. Но стоит выделить те которые явно влияют на скорость работы сети.
   > По большей части эти проблемы присущи TCP, но могут появиться и там где эмулируют TCP на другом протоколе (например UDP)
   * Packet loss <kbd>junior</kbd>
   * Reordering <kbd>middle</kbd>
   * Jitter <kbd>middle</kbd>
   * Round-Trip Time (RTT aka лаг) <kbd>junior</kbd>
1. IPv4, IPv6.
   > Базовое отличие протоколов надо знать, хотя бы, что б правильно создать колонку IP в базе и обработку в коде.
1. [DNS](https://developer.mozilla.org/ru/docs/Learn/Understanding_domain_names). <kbd>junior</kbd>
   > Ваш код 24/7 будет работать с доменами так как никто не использует чистый IP для соединения куда-либо.
   > Зная как работает DNS и управление резолвингом домена в системе можно упростить отладку в некоторых случаях.
   * [Как работает резолвинг доменов](https://temoto.github.io/a/kak-rabotayut-domeny.html) <kbd>junior</kbd>
   * [DNS записи](https://ru.wikipedia.org/wiki/Типы_ресурсных_записей_DNS) <kbd>middle</kbd>
     * Основные MX, CNAME, NS, A, AAAA, TXT <kbd>middle</kbd>
     * Прочие записи <kbd>middle+</kbd>
   * Файл `/etc/hosts` <kbd>junior</kbd>
     > Самый простой и доступный способ поменять IP любому домену, локально, конечно же.
   * Файл `/etc/resolv.conf` <kbd>middle+</kbd>
     > Конфигурация системы, как и где надо резолвить домены.
   * Консольные команды работы с доменами: `whois`, `dig`, `host`. <kbd>junior</kbd>
1. Трассировки маршрутов. <kbd>middle</kbd>
1. Анализ трафика через `tcpdump` + `wireshark` <kbd>guru ⚡</kbd>
   > Не простой, но очень эффективный способ "увидеть" и проанализировать трафик в удобном UI.
1. [Упороться сетью полностью](https://hpbn.co/) <kbd>guru ⚡</kbd>

# Этап 5. Базы данных

Без баз данных — никуда. Самый частый вид баз данных — реляционные базы данных.
Поэтому даже <kbd>junior</kbd> должен уметь работать с ними,
а вот с noSQL можно знакомится на поздних стадиях.

1. SQL базы данных MySQL/Postgres/итд. <kbd>junior</kbd>
   > MySQL подразумевает как MySQL от Oracle, так и различные варианты в виде MariaDB, Percona XTraDB и тд.
   > В общем понимании сеймества MySQL/Postgres/MSSQL/итд имеют схожие SQL API, различаются только внутренней реализацией, производительностью и масштабироемостью. Тут будет упор на MySQL семейство, которое очень распространено.
   * Базовый синтаксис запросов `SELECT`/`INSERT`/`UPDATE`/`DELETE`. <kbd>junior</kbd>
   * Создание и модификация таблиц <kbd>junior</kbd>
       * Типы колонок таблиц их назначение их различие (на примере MySQL и схожих) <kbd>junior</kbd>
           * tinyint/smallint/int/bigint
           * tinytext/text/mediumtext/longtext
           * set/enum
           * char/varchar
           * decimal
           * double
           * прочие
       * Создание и применение ALTER запросов. <kbd>junior</kbd>
   * Анализ выполнения запросов через `EXPLAIN`, понимание результатов `EXPLAIN`. <kbd>junior</kbd>
     > Самый действенный способ понять почему тормозит запрос.
   * Ведение логов медленных запросов — slow_log. <kbd>middle</kbd>
     > Не получится сидеть всё время, мониторя все запросы. Проще настроить агрегацию медленных запросов.
   * Индексы <kbd>junior</kbd>
     > Индексы очень важная часть баз данных. Ваши запросы всегда должны работать "по индексам".
     > Запрос без индекса или с "плохим" индексом, на нагруженных проектах, гарантировано может привести к падению проекта.
     * Назначение PRIMARY индексов <kbd>junior</kbd>
     * Назначение UNIQUE/обычных индексов <kbd>junior</kbd>
     * Составные индексы. <kbd>junior</kbd>
       > Условия и/или сортировки редко когда бывают по одному полю, обычно их больше. Вот тут на сцену выходят составные индексы.
       > Тут надо понимать что в составном индексе последовательность полей важна.
       * Понимание какие поля в какой последовательности добавлять в индекс при фильтрации и/или сортировке. <kbd>middle</kbd>
       * Понимание как строятся деревья индексов у составных индексов. <kbd>middle+</kbd>
     * [Понимание работы индексов](https://ruhighload.com/Индексы+в+mysql) <kbd>middle</kbd>
     * Алгоритм построения индексов `BTREE`. <kbd>guru ⚡</kbd>
       > Это понимание не сделает ваши запросы быстрее, но даст понятие как ведут себя те или иные данные в индексах.
     * Объединение таблиц `LEFT JOIN`, `RIGHT JOIN`, `INNER JOIN`, `OUTER JOIN`, `JOIN`. <kbd>junior</kbd>
       > Данные всегда "размазаны" по таблицам. Что бы их собрать потребуются эти операторы.
     * Группировка данных через `GROUP BY`. <kbd>junior</kbd>
       > Группировка данных — не редкие запросы, как правило, используются для сбора статистики.
       * Фильтрация после группировки. <kbd>junior</kbd>
       * Функции работы с группами MAX/MIN/AVG/итд <kbd>junior</kbd>
     * Понимание и назначение внешних ключей (`foreign key`) <kbd>middle</kbd>
       > Нередко используют внешние ключи для поддержания консистентности данных в базе.
     * Транзакции. <kbd>middle</kbd>
       > Что бы провести несколько операций атомарно (как одну операцию) используются транзакции.
       * Уровни изоляций транзакций. <kbd>middle</kbd>
       * Deadlock и как его не допускать. <kbd>middle+</kbd>
     * Триггеры на `INSERT`/`UPDATE`/`DELETE`. <kbd>middle</kbd>
       > Не стоит активно использовать триггеры.
       > Тем не менее они могут оказаться полезными в некоторых отладочных или maintenance случаях.
     * Хранение деревьев. <kbd>junior</kbd>
       > Не просто сохранить древовидную структуру в реляционной базе. Есть насколько алгоритмов со своими плюсами и минусами.
       > На самом деле актуально и для других видов баз данных
       * Алгоритм parent-child <kbd>junior</kbd>
         > Классический вариант "с parent_id" у дочерних элементов. Простые и "дешевые" на вставку элементов в деревья.
         > Но такие деревья затратные "на сборку".
       * Алгоритм [nested sets](https://devacademy.ru/article/nested-set) <kbd>middle</kbd>
         > Алгоритм позволяет достаточно дёшево собирать деревья с различными модификациями и сегментами.
         > Но затратные на вставку элементов в деревья.
1. Документо-ориентированная база данных (часть noSQL баз данных) — MongoDB. <kbd>middle</kbd>
   > Среди всех noSQL самой популярной является MongoDB.
   * Типы данных в коллекциях их назначение и их различие. <kbd>middle</kbd>
   * Анализ выполнения запросов через `explain()`, понимание его результатов. <kbd>middle</kbd>
   * Понимание работы индексов (аналогично SQL индексам с небольшими отличиями). <kbd>middle</kbd>
     * Sparse свойство индекса
     * Partial свойство индекса
     * TTL свойство индекса
     * Geospatial индекс
     * Text индекс
   * Вложенные объекты, массивы. <kbd>middle</kbd>
   * Агрегации <kbd>middle+</kbd>
   * Работа с репликацией. <kbd>middle+</kbd>
   * Работа с кластером MongoDb. <kbd>middle+</kbd>
1. Redis <kbd>junior</kbd>
   > Универсальный инструмент хранения данных с уклоном в производительность.
   > Может быть, как быстрым постоянным хранилищем, так и реактивным кеширующим временным хранилищем.
   * [базовая работа с ключами](https://redis.io/commands#generic) <kbd>junior</kbd>
   * [работа со списками](https://redis.io/commands#list) <kbd>junior</kbd>
   * [работа с хешами](https://redis.io/commands#hash) <kbd>junior</kbd>
   * [работа с набором](https://redis.io/commands#set) <kbd>junior</kbd>
   * [сортированным набором](https://redis.io/commands#sorted_set) <kbd>middle</kbd>
   * [Транзакции](https://redis.io/topics/transactions), но в другом, своём, понимании.
   * [Работа с Lua](https://redis.io/commands/eval) <kbd>middle</kbd>
     > Даёт вохможность запустить любой набор команд атомарно, долнтильно снабдив логикой.
1. Проблемы в базах данных <kbd>junior</kbd>
   * Deadlock <kbd>middle</kbd>
   * Переполнение числовых полей (в том числе autoincrement) <kbd>junior</kbd>
   * Full scan <kbd>middle</kbd>
   * Split-brain <kbd>middle+</kbd>

# Этап 6. Протокол HTTP

Каждый WEB разработчик должен понимать протокол HTTP.
Разработчик который не знает HTTP протокол — это как сапожник без сапог.
Поэтому даже <kbd>junior</kbd> должен знать много про протокол HTTP.

1. [Понимание общего формата протокола](https://developer.mozilla.org/ru/docs/Web/HTTP/Overview): где заголовки, а где тело. <kbd>junior</kbd>
1. Сродниться со вкладкой Сеть/Network в инспекторе браузера <kbd>junior</kbd>
   > В консоли можно наблюдать все HTTP запросы со страницы и даже делать самим через функцию `fetch`.
1. [Методы HTTP запросов.](https://developer.mozilla.org/ru/docs/Web/HTTP/Methods) Их назначение и ограничения. <kbd>junior</kbd>
   > Каждый метод имеет своё назначение (достаточно перевести названия методов) и, как следстиве, имеет свои условности и ограничения.
   * Основные [GET](https://developer.mozilla.org/ru/docs/Web/HTTP/Methods/GET), [POST](https://developer.mozilla.org/ru/docs/Web/HTTP/Methods/POST), [HEAD](https://developer.mozilla.org/ru/docs/Web/HTTP/Methods/HEAD) <kbd>junior</kbd>
   * Дополнительные `PUT`, `DELETE`, `PATCH` <kbd>middle</kbd>
     > Используюся в REST API вместе с основными методами
   * Прочие <kbd>middle+</kbd>
     > Это уже методы узкой направленности, редко когда придётся с ними напрямую работать. Тем не менее они активно используются приложениями.
1. [Коды HTTP ответов](https://developer.mozilla.org/ru/docs/Web/HTTP/Status) <kbd>junior</kbd>
   * Принцип разделения коды на группы 100-199, 200-299, 300-399, 400-499, 500-599. <kbd>junior</kbd>
     > Коды создавались и описывались не в хаотичном порядке. Есть чёткое разделение их "сфер влияния".
     > Даже если какой-то сервер придумает свой код ответа, то по группе сможете лучше понять причину такого ответа.
   * Основные (частые): [200](https://developer.mozilla.org/ru/docs/Web/HTTP/Status/200),
     [206](https://developer.mozilla.org/ru/docs/Web/HTTP/Status/206),
     [301](https://developer.mozilla.org/ru/docs/Web/HTTP/Status/301),
     [302](https://developer.mozilla.org/ru/docs/Web/HTTP/Status/302),
     [304](https://developer.mozilla.org/ru/docs/Web/HTTP/Status/304),
     [400](https://developer.mozilla.org/ru/docs/Web/HTTP/Status/400),
     [401](https://developer.mozilla.org/ru/docs/Web/HTTP/Status/401),
     [403](https://developer.mozilla.org/ru/docs/Web/HTTP/Status/403),
     [404](https://developer.mozilla.org/ru/docs/Web/HTTP/Status/404),
     [500](https://developer.mozilla.org/ru/docs/Web/HTTP/Status/500),
     [502](https://developer.mozilla.org/ru/docs/Web/HTTP/Status/502),
     [503](https://developer.mozilla.org/ru/docs/Web/HTTP/Status/503),
     [504](https://developer.mozilla.org/ru/docs/Web/HTTP/Status/504) <kbd>junior</kbd>
     > Это наиболее частые коды ответов которые гарантировано встретите.
   * [Другие](https://developer.mozilla.org/ru/docs/Web/HTTP/Status) <kbd>middle</kbd>
1. [Заголовки HTTP](https://developer.mozilla.org/ru/docs/Web/HTTP/Заголовки) <kbd>junior</kbd>
   * [MIME тип](https://developer.mozilla.org/ru/docs/Web/HTTP/Basics_of_HTTP/MIME_types) (тип документа) и заголовок типа [Content-Type](https://developer.mozilla.org/ru/docs/Web/HTTP/Заголовки/Content-Type). <kbd>junior</kbd>
     * Формат передачи `application/x-www-form-urlencoded` <kbd>junior</kbd>
     * Формат передачи [multipart/form-data](https://ru.wikipedia.org/wiki/Multipart/form-data) <kbd>middle</kbd>
   * Системные заголовки Host, Content-Length,
     [Content-Encoding](https://developer.mozilla.org/ru/docs/Web/HTTP/Headers/Content-Encoding),
     [Transfer-Encoding](https://developer.mozilla.org/ru/docs/Web/HTTP/Headers/Transfer-Encoding)) <kbd>junior</kbd>
   * [Кеширование HTTP](https://developer.mozilla.org/ru/docs/Web/HTTP/Кэширование), заголовки управления кешом: `Cache-Control`, `Expires`, `Vary`, `ETag`, `Last-Modified`.
1. [Куки](https://developer.mozilla.org/ru/docs/Web/HTTP/%D0%9A%D1%83%D0%BA%D0%B8) <kbd>junior</kbd>
   > На данный момент это единственный точный способ идентифицировать пользователя.
1. [Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/ru/docs/Web/HTTP/CORS) <kbd>middle</kbd>
   > Для кросс-доменных XHR/WebSocket запросов надо научиться работать с CORS иначе запросы не будут работать.
1. [Content-Security-Policy (CSP)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy) <kbd>middle</kbd>
   > Для повышения безопасности можно ограничить и указать что и откуда может загружаться и запускаться на странице.
1. Различия версий протокола HTTP/1.0, HTTP/1.1 <kbd>middle</kbd>
   > Не смотря появление новых версий протоколов HTTP версии HTTP/1.0 и HTTP/1.1 всё еще остаются частыми во внутренних сетях кластеров.
1. Консольные команды HTTP запросов `curl`, `wget` <kbd>junior</kbd>
   > На серверах (хостах) нет браузеров, чью удобную консоль можно использовать.
   > Там есть shell и множество утилит, которые умеют в HTTP.
1. HTTP/2.0 протокол и HTTP/3.0 <kbd>middle+</kbd>
1. WebSocket протокол <kbd>middle</kbd>
   > Это расширения HTTP/1.1 и более до механизма обмена данными по одному соединению.
   > Часто используется для чатов и/или для event-driven модели.
1. WebRTC <kbd>guru ⚡</kbd>
   > Если надо будет организовывать p2p чаты или p2p стриминг, то WebRTC как раз для этого.
1. HTTP API форматы <kbd>junior</kbd>
   * [REST API](https://ru.wikipedia.org/wiki/REST) <kbd>junior</kbd>
   * RPC <kbd>junior</kbd>
   * [GraphQL](https://habr.com/ru/post/326986/) <kbd>middle</kbd>
1. Web сервера <kbd>junior</kbd>
   * [Nginx](https://nginx.org). <kbd>junior</kbd>
     > Самый распространённый Web-сервер. Вероятность натолкнуться на него во время разработки web-приложения - велика.
     * [Ознакомление с базовыми возможностями](https://nginx.org/ru/docs/beginners_guide.html) <kbd>junior</kbd>
     * [Масштабируемая конфигурация nginx](https://www.youtube.com/watch?v=jf3wIN-FwW4) <kbd>middle</kbd>
     * Написание простых локаций в `/etc/nginx/nginx.conf` раздачи файлов <kbd>junior</kbd>
     * HTTP, FastCGI проксирование <kbd>junior</kbd>

# Этап 7. Безопасность

Ваше приложение всегда под угрозой, даже если это какая-то home-page.
Ботнетам всегда не хватает вычислительных ресурсов. Хакерам — данных. А пользователям — мозгов (без обид).

1. Виды управления доступом <kbd>middle</kbd>
   * Access Control List (ACL) <kbd>middle</kbd>
   * [Role-based access control](https://habr.com/ru/company/custis/blog/248649/) (RBAC) <kbd>middle</kbd>
   * [Attribute-based access control](https://habr.com/ru/company/custis/blog/248649/) (ABAC) <kbd>middle</kbd>
1. Аутентификация <kbd>junior</kbd>
   * [Basic](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication) <kbd>junior</kbd>
     > Самый простой вид авторизации, не требующий дополнительных вычислительных мощностей (серверов).
   * [OAuth2](https://www.digitalocean.com/community/tutorials/oauth-2-ru) <kbd>middle</kbd>
     > Распространенный вид авторизации через посредника, который гарантирует что Вы это Вы и может выдать некоторые данные по пользователю, с его согласия.
     > Часто сталкиваются c OAuth2 тогда когда надо подключить авторизацию через соц. сети. У них у всех oauth2 (но каждый со своими модификациями).
   * Ldap <kbd>middle</kbd>
     > Данный вид авторизации используется, чаще всего, для авторизации во внутренних сервисах своих сотрудников.
   * JSON Web Token (JWT) <kbd>middle</kbd>
     > Это не тип авторизации, а инструмент для передачи идентифицирующих данных. Однако такой токен может иметь очень широкое применение
1. [Виды атак и уязвимостей](https://docs.wallarm.ru/attacks-vulns-list/) <kbd>junior</kbd>
   * Фишинг сайта <kbd>junior</kbd>
   * Небезопасное перенаправление, Open Redirect <kbd>junior</kbd>
   * Инъекции (например SQL-инъекции) <kbd>junior</kbd>
   * XSS атака <kbd>junior</kbd>
   * IDOR уязвимость <kbd>middle</kbd>
   * CRLF атака <kbd>junior</kbd>
   * LFI/RFI атака <kbd>junior</kbd>
   * DoS/DDoS <kbd>middle</kbd>
     * HTTP-флуд <kbd>middle</kbd>
     * SYN flood (потребуются знания TCP) <kbd>middle+</kbd>
     * UDP flood (UDP амплификация) <kbd>middle+</kbd>
     * Медленный запрос <kbd>middle</kbd>
   * Бомбы <kbd>middle</kbd>
      * Logic Bomb <kbd>middle</kbd>
      * Zip Bomb <kbd>junior</kbd>
   * Атака посредника (Man In The Middle, MITM) <kbd>middle</kbd>
   * Брутфорс (например брутфорс паролей) <kbd>junior</kbd>
   * Спуфинг <kbd>middle</kbd>

# Этап 8. Тут должен быть ваш язык программирования

Языков программирования большое множество.
Поэтому этот этап будет задевать только часто встречающиеся вопросы в большинстве популярных языков программирования.
И не будет сильно дробиться на градации, так как это полностью зависит от самого языка.
Принцип работы с этим разделом: гуглите `%ваш_язык_программирования% %пункт_из_этапа%`.
Учтите, что **некоторых пунктов может не быть в вашем языке**.

1. Что такое интерпретатор, компилятор, JIT, оп-код, байт-код. Что из этого использует ваш язык? <kbd>junior</kbd>
1. Ваш язык программирования <kbd>junior</kbd>
   * Базовые (примитивные) типы данных в языке.
   * Объекты/классы/прототипы/структуры.
   * Ссылки, слабые ссылки.
   * Garbage Collector.
   * Преобразование типов.
   * Слабая/сильная типизация в коде. На что влияет и как с этим жить.
   * Битовые операции: `not`, `and`, `or`, `xor`, сдвиг влево, сдвиг вправо <kbd>junior</kbd>
   * Обработка ошибок. Исключения, паники, error и прочие проявления _ошибок_.
   * Проблемы в коде
     * Бесконечные циклы
     * Рекурсии
     * Ошибка сегментации (и ее связь с сигналом SIGSEGV)
1. Распараллеливание <kbd>middle</kbd>
   * Различие процессов (созданные через [fork](https://ru.wikipedia.org/wiki/Fork)) от потоков (thread)
     * Поведение дескрипторов до и после fork
   * Потоки (threads)
     * Истинные потоки (pthreads, posix-threads)
     * Зелёные потоки (Green threads)
   * Процессы
     * Разделяемая память (Shared memory)
     * Межпроцессное взаимодействие (IPC)
   * КоРутины
   * Проблемы распараллеливания
     * Race Condition
   * Блокировки 
   * Атомарные операции
1. Пакетный менеджер или менеджер зависимостей. <kbd>junior</kbd>
1. Расширения языка
   > Высокоурвоневые языки, обычно, расшираяются модулями, написанными на низкоуровневом языке, на котором написан сам обработчик языка.
1. Запуск сервера и работа c ним в языке (обработка HTTP запросов). <kbd>junior</kbd>
   > Некоторые языки в коде запусают сервера, а некоторые имею отдельный сервер который запускает код. Может быть и то и то.
1. Кеширование данных <kbd>middle</kbd>
   * Частые алгоритмы кеша [LRU](https://ru.wikipedia.org/wiki/Алгоритмы_кэширования#Least_recently_used_(Вытеснение_давно_неиспользуемых)), LFU
   * [Иные алгоритмы кеширования](https://ru.wikipedia.org/wiki/Алгоритмы_кэширования) <kbd>guru ⚡</kbd>
   * Прогревание кеша, инвалидация кеша
1. Шаблонизация
   > Генерировать UI через `print`-ы очень плохая практика из-за множества проблем с поддержкой такого кода с ростом проекта и контрибуторов.
   > В Вашем языке должны быть пакеты/модули для шаблонизации. И, как правило, их несколько.
1. Юнит тестирование <kbd>junior</kbd>
   > Ознакомление с системой тестирования в вашем языке. Подбор пакета/модуля для тестирования.
1. Специфика работы IO (сокетов, дескрипторов, потоков) <kbd>middle</kbd>
   * Буферы IO
   * Асинхронный IO

# Этап 9. Электронная почта

Работа с email неотъемлемая часть web разработки (да и не только). По факту, это едиственный гарантированный канал связи с пользователем.

1. [Спецификация письма MIME](https://www.opennet.ru/docs/RUS/inet_server/servers_glava2_5.html) <kbd>middle</kbd>
   * Основные заголовки: `Return-Path`, `Received`, `From`, `To`, `Cc`, `Bcc`, `Reply-To`, `Subject`, `Message-ID` <kbd>middle</kbd>
   * прочие заголовки <kbd>middle+</kbd>
   * указание кодировки <kbd>middle</kbd>
   * кодирование полей и тела в base64 <kbd>middle</kbd>
1. Установка [MailHog](https://github.com/mailhog/MailHog) <kbd>middle</kbd>
   > Это почтовый сервер для тестирования работы отправки писем приложениями, который можно поднять локально в контейнере.
1. Протоколы передачи почты POP3, IMAP <kbd>guru ⚡</kbd>

# Этап 10. Полнотекстовый поиск

Каждый разработчик сталкивается с необходимостью полнотекстового поиска, да и в целом быстрого поиска по куче аттрибутов и текстов.
Для этого используются различные полнотекстовые поисковые движки такие как [ElasticSearch](https://www.elastic.co/), [SphinxSearch](http://sphinxsearch.com/), [ManticoreSearch](https://manticoresearch.com/) и тд.
Самый распространенный полнотекстовый поисковый движок с большим сообществом — ElasticSearch.

1. Установить [Cerebro](https://github.com/lmenezes/cerebro) для работы с ElasticSearch. <kbd>junior</kbd>
1. Индексы <kbd>junior</kbd>
   * Alias <kbd>middle</kbd>
   * Настройки <kbd>middle+</kbd>
   * Шаблоны <kbd>middle</kbd>
   * Mapping <kbd>middle</kbd>
1. Запросы <kbd>junior</kbd>
   * Запросы поиска <kbd>junior</kbd>
   * Запросы добавления/обновления/удаления документов <kbd>junior</kbd>
   * bulk запросы <kbd>middle</kbd>
     > Запросы на изменение лучше делать пачкой, так называемым bulk-ом.
   * painless-скриптинг <kbd>middle</kbd>
     > потребуется что бы точечно обновить некоторые поля у документа или вложенные документы, вместо всего документа
1. Подключение морфологий <kbd>junior</kbd>
1. Агрегации <kbd>middle+</kbd>
1. Работа с nested-документами <kbd>middle</kbd>

# Этап 11. Логи и метрики

Метрики позволят узнать о проблеме, а логи позволят понять причину проблемы. Для крупных и/или распределённых систем этот тандем обязателен.
Для обработки большого объёма данных нужны подходящие системы для сбора, хранения и агрегации.
Любое приложение должно уметь генерировать _полезные_ метрики для системы сбора и анализа метрик. И писать _правильные_ систменые логи о _своих_ событиях. 
Логи о событиях пользователей уже относится к аудиту, а не к системным логам.

1. Системы хранение и обработка логов
   > Их на самом деле много, но среди бесплатных opensource, по популярности выделяются несколько
   * Решение [ELK](https://www.elastic.co/what-is/elk-stack) <kbd>middle+</kbd>
     > Не самая тривиальная, но эффективная для приёма, обработки, хранения и работы с логами.
     > ELK: Logstash - парсит логи, ElasticSearch - хранит логи, Kibana - UI для ElasticSearch для работы с логами.
   * [ClickHouse](https://clickhouse.tech/docs/ru/) <kbd>middle+</kbd>
     > Колоночная база данных, которая отлично справляется с большим количеством логов (и не только access). Если проводить аналогию с ELK то:
     > MaterializedView - позволяет парсить (структурированные) логи, семейство MergeTree — хранит логи.
     > А вот UI только сторонний брать, например Grafana или [Kibana](https://www.highload.ru/moscow/2019/abstracts/5906).
1. [Prometheus](https://prometheus.io/) или подобные, например, [Victoria Metrics](https://victoriametrics.com/) <kbd>middle</kbd>
   > Популярная система сбора и хранения метрик.
   * Типы метрик <kbd>middle</kbd>
     * count
     * gauge
     * histogram
     * summary
   * Варианты отправки метрик: push и pull <kbd>middle</kbd>
   * Запросы (лучше и наглядней делать из Grafana) <kbd>middle</kbd>
     * [Синтаксис](https://prometheus.io/docs/prometheus/latest/querying/basics/) <kbd>middle</kbd>
     * Лейблы
     * Векторы
     * Интервалы
     * Операторы
   * [Функции](https://prometheus.io/docs/prometheus/latest/querying/functions/), особенно стоит выделить 2 из них: <kbd>middle</kbd>
     * rate
     * irate
1. Grafana <kbd>middle+</kbd>
   > Отличный UI для отображения метрик из разных систем хранения, включая Prometheus-like системы.
   * Создание дашбордов
   * Создание графиков
   * Настройка алертов

# Этап 12. Проектирование и разработка

Паттерны, концепции и подходы к проектированию различных web-приложений.

1. Принципы разработки <kbd>junior</kbd>
   * GRASP (General Responsibility Assignment Software Patterns) <kbd>middle</kbd>
   * [SOLID](https://blog.byndyu.ru/2009/10/solid.html) (Single responsibility, open–closed, Liskov substitution, interface segregation, dependency inversion) <kbd>middle</kbd>
   * KISS (Keep it simple, stupid) <kbd>junior</kbd>
   * YAGNI (You aren't gonna need it) <kbd>junior</kbd>
   * DRY (Don’t repeat yourself) <kbd>junior</kbd>
   * IoC (Inversion of Control), и как следствие — DI (Dependency Injection) <kbd>middle</kbd>
   * DDD (Domain-driven design) <kbd>middle</kbd>
1. Архитектурные шаблоны <kbd>junior</kbd>
   > В одном проекте может быть один или несколько архитектырных шаблонов, или даже половина. Архитектурные шаблоны - не архитектура вашего приложения. 
   > Это подход к решению задачи, которую взоложили на проект. Заумно вышло...
   * Гексагональная архитектура <kbd>middle+</kbd>
   * [Event-Driven Architecture](https://habr.com/ru/post/346630/) (aka Шаблон посредника или Broker pattern) <kbd>middle+</kbd>
   * Onion Architecture (аkа Луковая архитектура или Многоуровневый шаблон) <kbd>middle+</kbd>
   * CQRS (The Command and Query Responsibility Segregation) <kbd>middle+</kbd>
   * Шаблон MVC <kbd>junior</kbd>
     > Самый старый и достаточно распространённый шаблон проектирования приложения, разделяющий UI от логики приложения.
   * Шаблон MVP <kbd>junior</kbd>
     > MVP - итерация развития MVC из-за усложнений приложений и UI. Часто используется в front-end - в браузере.
   * Шаблон [MVVM](https://habr.com/ru/company/mobileup/blog/313538/)
     > На самом деле этот шаблон подходит для десктопных или мобильных приложений. В web приложениях практически не используется.
1. [Шаблоны проектирования](https://refactoring.guru/ru/design-patterns/examples)
   > Шаблоны упрощают разработку, так как это, по сути, опыт сообщества по решению тех или иных проблем. 
   > Главное не забывайте про KISS и YAGNI что бы не упасть в ад абстракций и пучину сложости.
   * Порождающие шаблоны проектирования
   * Структурные шаблоны проектирования
   * Поведенческие шаблоны проектирования
1. Методологии разработки
   * [TDD](https://habr.com/ru/company/ruvds/blog/450316/) (Test Driven Development)
   * BDD (Behavior Driven Development)
1. Тестирование
   * Unit тестирование
   * Интеграционные тесты
   * End-to-End (aka E2E aka Сквозное тестирование)
   * Smoke test (aka дымовые тесты)
1. [Приёмы рефакторинга](https://refactoring.guru/ru/refactoring/techniques)
1. [Антипаттерны](https://ru.wikipedia.org/wiki/Антипаттерн)
1. [Semver](https://semver.org/lang/ru/)
   > Самый распространённый принцип наименования версий приложения. В некоторых языках и пакетных менеджерах является обязательным к соблюдению.
1. Распределенные системы
   * [Теоремы CAP и PACELC](https://habr.com/ru/company/gaz-is/blog/551986/)
     > В распределённых системах придётся чем-то жертвовать. PACELC - расширенная теорема CAP.
     > Эти теоремы как раз описывают какими параметрами придётся пожертвовать системе.
   * [Микросервисная архитектура](https://dataart.team/ru/news/microservices-kak-pravil-no-delat-i-kogda-primenyat/)
