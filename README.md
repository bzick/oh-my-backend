Oh My BackEnd
=============

**Что это?** Этот документ содержит список (roadmap) навыков, которые **часто** требуются backend разработчику web-приложений. Документ разделён на этапы (темы). Каждый этап разделён на пункты. Каждый пункт, в документе, подразумевает что:
- бекендер знает что это и какую проблему решает.
- бекендер знает для чего и когда следует применить.
- бекендер знает как с этим работать или знает где подсмотреть.
- при разработке или проектировании бекендер помнит про них и учитывает в приложении.

Понимание принципа работы каждого пункта будет дополнительным бонусом в понимании всей темы, но это может занять много времени. Изучайте по желанию и необходимости.

**Как работать с документом?** Этапы и пункты выстроены в рекомендуемом порядке для изучения. Просто следуйте сверху-вниз.

**Как работать с пунктами документа?** Каждый пункт легко гуглится и имеет страницу в wikipedia. 
Ссылки устанавливаются если есть альтернативная документация — более понятная и/или более подробная.
Ссылка на wikipedia ставятся для уточнения если название статьи неочевидно или можно перепутать статьи.
> Цитатой обозначены пояснения к пункту для чего следует это знать и/или где с этим можно столкнуться. 
> Если пояснения нет — то либо не успели сделать, либо там и так ясно.

**Есть-ли разделение по скилам?** Каждый пункт делится на градации <kbd>junior</kbd>, <kbd>middle</kbd>, <kbd>middle+</kbd> (он же <kbd>high middle</kbd>). 
Градации используются что бы помочь выставить приоритеты в различных темах — на то что стоит изучать в первую очередь. 
Тут применяется [общепринятая градация](https://vas3k.ru/blog/team/) навыков и зон ответственности, где <kbd>senior</kbd> это <kbd>middle+</kbd> с soft-скилами.
В данном документе максимальным уровнем градации будет — <kbd>middle+</kbd>, так как этот документ акцентирует внимание на hard-скилах.

Метка <kbd>guru ⚡</kbd> означает что этот пункт для более глубокого и продвинутого изучения темы (если у Вас есть время).

**В каком состоянии документ?** Документ еще находится в процессе дополнений и правок. 
В идеале каждый пункт должен иметь градацию, иметь пояснение и ссылку на толковое разъяснение на русском языке. 
До идеала еще далеко, но начало положено!

Если хотите что-то изменить (пункт, ссылку, опечатку) — создавайте [issue](https://github.com/bzick/oh-my-backend/issues) или делайте [pr](https://github.com/bzick/oh-my-backend/pulls). 
Если хотите обсудить документ — создавайте обсуждение в [discussions](https://github.com/bzick/oh-my-backend/discussions).

# Содержание

- [Этап 1. Виртуализация docker](#этап-1-виртуализация-docker)
- [Этап 2. Linux](#этап-2-linux)
- [Этап 3. Общие знания](#этап-3-общие-знания)
- [Этап 4. Сеть](#этап-4-сеть)
- [Этап 5. Базы данных](#этап-5-базы-данных)
- [Этап 6. Протокол HTTP](#этап-6-протокол-http)
- [Этап 7. Безопасность](#этап-7-безопасность)
- [Этап 8. Тут должен быть ваш язык программирования](#этап-8-тут-должен-быть-ваш-язык-программирования)
- [Этап 9. Электронная почта](#этап-9-электронная-почта)
- [Этап 10. Полнотекстовый поиск](#этап-10-полнотекстовый-поиск)
- [Этап 11. Логи и метрики](#этап-11-логи-и-метрики)
- [Этап 12. Проектирование и разработка](#этап-12-проектирование-и-разработка)

# Этап 1. Виртуализация docker

Для начала надо поднять виртуальную машину для экспериментов и исследований. В случае чего, виртуальную машину всегда можно пересоздать.

Есть много систем виртуализации, но docker выделяется среди них. Docker — популярный инструмент для десктопной виртуализации. На боевых серверах к нему прибегают в меньшей степени, так как там более популярен Kubernetes (aka k8s). Docker не единственная система виртуализации, ближайшие аналоги это [Lima](https://github.com/lima-vm/lima), [Podman](https://podman.io/) (нечто среднее между `docker` и `k8s`).

1. установить [docker](https://www.docker.com/products/docker-desktop) <kbd>junior</kbd>
1. запустить контейнер с Linux Ubuntu, последней [LTS версией](https://ru.wikipedia.org/wiki/Список_версий_Ubuntu#Выпуски). Запустить bash (консоль) контейнера. <kbd>junior</kbd>
1. установить удобное приложение для управления образами и контейнерами [Kitematic](https://kitematic.com/), [Portainer](https://hub.docker.com/r/portainer/portainer/) и т.д. 
   Либо сродниться с консольными командами docker. На некоторых OC десктопный docker уже имеет [свой dashboard](https://docs.docker.com/desktop/dashboard/) для управления образами и контейнерами. <kbd>junior</kbd>
1. docker compose для поднятия кластера контейнеров. <kbd>middle</kbd>
   > Для рабочего приложения, как правило, требуется несколько различных сервисов (база данных, кэшер, http-сервер и т.д.)
   > и всё это упаковать в один docker контейнер будет проблемно, просто из-за специфики работы самой виртуализации.
   > Тут как раз поможет compose что бы запустить кучу контейнеров и подружить их между собой.

# Этап 2. Linux

Изучить установленный в контейнере — Linux. Linux, де-факто, является серверной ОС для большинства web-приложений. 
В этом разделе будет говориться о Linux, хотя (почти) всё так же актуально и для других posix-совместимых систем. Например для [bsd семейства](https://ru.wikipedia.org/wiki/BSD), включая MacOS. Однако, могут быть отличия. 
В качестве стартового дистрибутива Linux, обычно, выбирают [Ubuntu](https://ru.wikipedia.org/wiki/Ubuntu), но вы можете взять самый компактный - [Alpine](https://ru.wikipedia.org/wiki/Alpine_Linux), который часто используется в виртуализации.

1. Установка пакетов и обновление системы через `apt`/`apt-get` в Ubuntu/Debian и `apk` в Alpine. <kbd>junior</kbd>
   > В процессе исследований и различных проб придётся много раз ставить, обновлять и переустанавливать множество пакетов Linux.
   > Лучше сразу изучить как работают эти команды. Нужны бызовые операции: найти, установить, обновить, удалить.
1. Базовые навыки в `bash` (улучшенный `sh` aka `shell`). <kbd>junior</kbd>
   > В Linux-подобных системах bash'ем пронизано всё. Вы гарантировано столкнётесь с ним и будут случаи когда надо будет писать bash/shell скрипты.
   * Базовый синтаксис bash. <kbd>middle</kbd>
     > По факту это единственный скриптовый язык который гарантированно будет установлен в системе.
     * Управляющие операторы `if`, `for` и `while`
     * Логические операторы `;`, `&&`, `||`
     * Исполняющие выражения `` `cmd` `` и `$(cmd)`
   * Базовые команды для работы с файловой системой `cd`, `ls`, `find`, `cat`, `cp`, `mv`, `mkdir`, `rmdir`, `rm`. <kbd>junior</kbd>
   * Вызов мануалов через команду `man`. <kbd>junior</kbd>
     > Через эту команду можно получить справку по любой команде, операции, файлам и даже исходному коду.
   * Конвейеры команд через оператор `|` (`cmd1 | cmd2 | cmd3`). <kbd>junior</kbd>
     > Linux имеет большое количество команд для обработки данных и для решения различных задач которые вам может понадобится объединять через конвейеры.
   * Команды обработки данных `cat`, `tail`, `head`, `grep`, `awk`, `sed`. <kbd>middle</kbd>
     > Этот набор потребуется для сканирования и анализа логов или больших объёмов текстовых данных.
   * Команды работы с архивами данных `zcat`, `gzip`, `gunzip`, `tar`, `zgrep`. <kbd>middle</kbd>
     > Как правило, никто не хранит логи или большие объёмы текстовых данных "как есть", обычно это архив `gz` или `tar.gz` (`tgz`).
   * [Консольные редакторы vim, nano.](https://gitlab.com/doatta/gnu-linux-rhcsa/-/blob/master/10.%20Текстовые%20редакторы%20nano%20и%20vi.md) Открыть файл, внести изменения, сохранить. <kbd>junior</kbd>
     > Редактирование файла из консоли не такая редкость. Кстати, что бы выйти из vim: esc, напечатайте `:q!`, enter.
   * Консольные просмотрщики `less`, `zless`. Открыть, найти слово, закрыть. <kbd>junior</kbd>
     > Редакторы избыточны, что бы просто посмотреть содержимое файла. Просмотрщики так же справляются с не "стандартными" для редакторов файлами.
   * Фоновые задачи, оператор `&`, команды `jobs`, `fg`, `bg`. <kbd>middle</kbd>
     > Оператор позволит в одной shell-сессии запускать несколько команд.
   * Команда игнорирования сигналов прерываний `nohup`. <kbd>middle</kbd>
     > Команда позволит, при завершении shell-сессии, оставлять в живых запущенные фоновые задачи до их логического завершения.
   * [Потоки, перенаправление потоков](http://gitlab.com/doatta/gnu-linux-rhcsa/-/blob/master/11.%20Стандартные%20потоки.md), операторы `>`, `>>`, `<`. <kbd>junior</kbd>
     > Куда писать вывод, а куда ошибки, помогут указать эти операции.
   * [Упороться полностью консолью](https://github.com/jlevy/the-art-of-command-line/blob/master/README-ru.md) <kbd>guru ⚡</kbd>
1. Понятие `процесс`. <kbd>junior</kbd>
   > Как и во всех других ОС, в Linux запущенные приложения представляются процессами.
   * Команды анализа процессов `top`, `htop`, `ps` (`ps aux`). <kbd>junior</kbd>
     > Этакий "диспетчер задач" в мире Linux, позволяющий мониторить процессы системы.
   * Родительский процесс, дочерний процесс. <kbd>middle</kbd>
     > Процессы не появляются из ниоткуда, их что-то запускает. Понимание иерархии процессов облегчит работу с ними и сделает проще понимание мультипроцессовых приложений.
   * Мастер-воркер процессы, демон (daemon). <kbd>middle</kbd>
     > Это один из распространённых видов распараллеливания вычислений в приложениях. Много программ используют именно такой подход распараллеливания.
   * Зомби-процессы. Откуда берутся и как с ними бороться. <kbd>middle+</kbd>
     > Это вид проблемы распараллеливания вычислений через дочерние процессы. Возникает когда у мастер-процесса есть проблемы или баги.
   * [Отправка сигналов процессам](https://ru.wikipedia.org/wiki/Сигнал_(Unix)). <kbd>junior</kbd>
     > Это основной рычаг воздействия на процессы сторонними приложениями (системными или вашими).
       * Изучение команд `kill`, `pkill`, `killall`. <kbd>junior</kbd>
       * Назначение сигналов [SIGKILL](https://ru.wikipedia.org/wiki/SIGKILL), [SIGTERM](https://ru.wikipedia.org/wiki/SIGTERM), [SIGINT](https://ru.wikipedia.org/wiki/SIGINT), [SIGHUP](https://ru.wikipedia.org/wiki/SIGHUP), [SIGSEGV](https://ru.wikipedia.org/wiki/SIGSEGV). <kbd>middle</kbd>
   * Системный вызов (syscall). <kbd>middle+</kbd>
     > Системный вызов (вызов API ядра Linux) — не бесплатная операция и лучше их держать под контролем на высоконагруженных приложениях.
   * Команда анализа системных вызов процесса через `strace`. <kbd>middle+</kbd>
     > Самый простой и доступный способ посмотреть какие системные вызовы делает процесс в реальном времени.
1. Изучение понятия `дескриптор`. <kbd>middle</kbd>
   > Любой поток данных (входящий и/или исходящий) представляется в виде дескрипторов. Что-либо читать или писать будете (вероятней всего) через дескриптор.
   * Стандартные дескрипторы `STDIN`, `STDOUT`, `STDERR` и их нумерация. <kbd>middle</kbd>
     > Любой поток в процессе пронумерован и есть "зарезервированные" номера под определенные потоки.
   * Потоки, сокеты и unix-сокеты. <kbd>middle</kbd>
     > Это всё разновидности дескрипторов с которыми придётся работать. На всех них распространяются правила дескрипторов, ну так как они и есть дескрипторы.
   * Ограничение на дескрипторы. <kbd>middle+</kbd>
     > Не редкая проблема приложений когда оно упирается в лимит открытых дескрипторов.
   * Команда анализа открытых дескрипторов у процесса через `lsof`. <kbd>middle+</kbd>
     > Для отладки приложения всегда надо знать с чем ведёт общение приложение (отлично работает в паре с `strace`, сопоставляя номера дескрипторов).
1. [Пользователи](https://gitlab.com/doatta/gnu-linux-rhcsa/-/blob/master/19.%20Пользователи.md) <kbd>junior</kbd>
   * Пользователь `root`. <kbd>junior</kbd>
     > По сути это админ системы. Избегайте использование root (даже в контейнерах) так как доступ к root даёт доступ ко всей системе, о чем мечтают все зловерды.
   * Супер пользователь, команды [su](https://gitlab.com/doatta/gnu-linux-rhcsa/-/blob/master/17.%20su.md) и [sudo](https://gitlab.com/doatta/gnu-linux-rhcsa/-/blob/master/18.%20sudo.md). <kbd>junior</kbd>
     > Никто не даст вам root на проде, но вполне можете иметь "привилегированного" пользователя, который умеет в `sudo`.
1. [Файловая система](https://gitlab.com/doatta/gnu-linux-rhcsa/-/blob/master/04.%20%D0%9E%20%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D1%8B%D1%85%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0%D1%85.md) <kbd>junior</kbd>
   * Команда `stat` <kbd>junior</kbd>
   * [Права и доступы файловой системы](https://gitlab.com/doatta/gnu-linux-rhcsa/-/blob/master/20.%20Права%20на%20файлы.md) <kbd>junior</kbd>
     > Избыточные доступы ведут к дыре в безопасности, недостаток доступов ведёт к багам в приложении. Осмысленно ставьте где `x` (особенно у директорий), где `r`, а где `w`.
   * Понимание описания доступов вида `--xr-xrwx` и `0137` (восьмеричная) у файлов и директорий. <kbd>junior</kbd>
     > Обычно в таком виде вы будете видеть уровни доступов в консолях.
   * Исполняемые файлы, [sha bang](https://ru.wikipedia.org/wiki/Шебанг_(Unix)). <kbd>junior</kbd>
   * Изменение прав доступов через команды `chmod`, `chown`. <kbd>middle</kbd>
   * [Работа с дисками](https://gitlab.com/doatta/gnu-linux-rhcsa/-/blob/master/22.%20Работа%20с%20дисками.md) <kbd>middle+</kbd>
     > Нужно знать где, как и куда примонтированы различные диски или носители. Бывает, что приложение может работать сразу с несколькими дисками, некоторые могут быть сетевыми.
1. Ссылки на файловой системе. <kbd>junior</kbd>
   * Symlink (aka символическая ссылка). <kbd>junior</kbd>
     > Самый распространённый вид ссылки. Повсеместно используется в Linux да и пакетных менеджерах разных языков. Вы тоже будете это использовать.
   * Hardlink (aka жесткая ссылка). <kbd>middle</kbd>
     > Редкий случай использования ссылки. Потребуется если надо "дедуплицировать" большой объём файлов.
     > По сути позволяет создать несколько имён одному файлу.
1. Запуск и остановка сервисов systemd. <kbd>middle</kbd>
   > Linux по сути просто пачка запущенных приложений как сервисов.
1. [SSH](https://ru.wikipedia.org/wiki/SSH). <kbd>junior</kbd>
   > Самый доступный способ запустить `shell` на удалённой машине это использовать SSH. Используется повсеместно.
   * Генерация собственного ssh-rsa ключа через `ssh-keygen`. <kbd>junior</kbd>
     > Без него вы не попадёте на хосты по SSH.
   * Использование публичного ssh-rsa ключа для входа на удалённую машину (используйте второй контейнер с Linux). <kbd>junior</kbd>
1. Перенос контента. <kbd>junior</kbd>
   > Появляется потребность перекинуть логи, дамп базы и другие файлы между машинами или к себе.
   * `scp` <kbd>junior</kbd>
     > самый простой инструмент переноса файлов между хостами по ssh.
   * `rsync` <kbd>middle</kbd>
     > пожалуй самый мощный инструмент переноса файлов между хостами с кучами настроек, правил и протоколов.
   * `rclone` <kbd>middle</kbd>
     > "rsync" для облачных хранилищ. Универсальный инструмент для работы с контентом, который хранится в облаках или где-то по сети. 
1. Планировщики задач
   * Команда `crontab` и запуск `crond`.
     > Самый распространённый и простой планировщик задач, с весьма гибкими настройками расписания
   * Команда `at` <kbd>middle</kbd>
     > Когда хотите запустить задачу разово, к определенному времени.
     > В crontab это потребует отдельно создавать расписание, что сильно затрудняет автоматику и захламляет всё расписание.
1. Оперативная память. <kbd>middle</kbd>
   * Команда `free`, мета информация `/proc/meminfo`. <kbd>middle</kbd>
     > Всегда оценивайте сколько памяти потребуется приложению или скриптам, что бы не быть убитыми системой.
   * Ошибка `Out Of Memory` (OOM) и причина появления. [OOM-киллер](https://habr.com/ru/company/southbridge/blog/464245/). <kbd>middle+</kbd>
     > Именно это происходит когда вы превысили все допустимые пределы потребления памяти в системе.
1. [Логи системы](https://habr.com/ru/post/332502/). Для чего и как посмотреть. <kbd>middle</kbd>
   > Когда случаются проблемы то логи — единственное, что может навести на суть проблемы. 
   > Помимо логов приложения стоит заглядывать в логи системы, иногда её проблема может вести к проблеме в приложениях. Стоит выделить некоторые логи:
   * `dmesg` (driver messages) — важные сообщения от компонентов Linux, включая от OOM-киллера. <kbd>middle</kbd>
   * `syslog` — системный журнал. <kbd>middle</kbd>
     > Там могут быть сообщения от ядра Linux, различных служб, сетевых интерфейсов и многого другого.
1. Проблемы в Linux и последствия. <kbd>junior</kbd>
   > Их много, но выделим только несколько.
   * Kernel panic. <kbd>junior</kbd>
     > BSoD аналог для Linux. Самая не приятная ошибка системы, явно намекающая, что система не стабильна.
   * Segmentation fault (aka segfault aka сегфолт). <kbd>middle</kbd>
     > Не такая уж и редкая ошибка приложений, как хотелось бы. Приложение попыталось работать с памятью доступа к которой у неё нет.
   * Core dump (aka корка). <kbd>middle+</kbd>
     > Результат обработки segmentation fault системой. Корка может потребоваться разработчику упавшего приложения для анализа состояния программы на момент падения.

# Этап 3. Общие знания

Некоторые пункты сложно категоризировать в этом документе. Но без них не обойтись. 
Это базовые вещи которые используются повсеместно в коде, в системах, "под капотом" вашего языка программирования.

1. Регулярные выражения. Поиграться регулярными выражениями можно [тут](https://regex101.com/). Хоть каждый язык может иметь своё видение регулярных выражений, в общем смысле (и синтаксисе) они похожи. <kbd>middle</kbd>
   > Рано или поздно придётся спарсить данные из текста или провалидировать данные, вот тут как раз и потребуются регулярные выражения.
1. Криптография. <kbd>junior</kbd>
   > Не пугайтесь. Пункт подразумевает прикладное применение криптографических функций (для чего нужны те или иные функции), а не изучении самой криптографии.
   *  Хеши и хеш-функции, в том числе `crc32`, `md5`, `sha1`, `sha256`. <kbd>junior</kbd>
   * Цифровые подписи. <kbd>junior</kbd>
     > Что бы обезопасить от подделки данных используются цифровые подписи этих же данных.
   * Соль для подписей. <kbd>middle</kbd>
     > В теории (да и на практике) хеш-функцию можно определить и что бы сильнее обезопасить от "взлома" вашего хеша, используя так называемую соль.
   * Коллизии хешей. <kbd>middle</kbd>
     > Хеш-функции могут на разных данных вернуть один и тот же результат (хеш), что может привести к проблемам и багам.
     > Лучше знать какова вероятность коллизий у хеш-функции и как их избегать.
   * Симметричное и асимметричное шифрование. <kbd>middle+</kbd>
     > Иногда приходится шифровать данные и важно выбрать стратегию шифрования.
   * [Принцип работы TLS](https://habr.com/ru/post/188042/). <kbd>middle+</kbd>
     > Имеется ввиду как работаю CA корневые и промежуточные, что стоит за сертификатом.
1. [Базовая работа с `git`](https://www.youtube.com/watch?v=zZBiln_2FhM). <kbd>junior</kbd>
   > По факту это дефолтная система контроля версий в мире IT.
   * Коммит изменений (commit) <kbd>junior</kbd>
   * Отправка изменений (push/pull) <kbd>junior</kbd>
   * Создание веток и тегов (branch/tag) <kbd>junior</kbd>
   * Слияние веток (merge) <kbd>junior</kbd>
   * [Упороться полностью git'ом](https://git-scm.com/book/ru/v2) <kbd>guru ⚡</kbd>
1. Структуры данных. <kbd>junior</kbd>
   * Хеш таблицы. <kbd>middle</kbd>
     > Таблицы часто используются в самих языках программирования (ассоциативные массивы, объекты и т.п.)
   * Очередь и стек. <kbd>junior</kbd>
     > Самые простые структуры данных, которые часто придётся использовать повседневно в коде.
   * [Связный список](https://ru.wikipedia.org/wiki/Связный_список) и [двусвязный список](https://ru.wikipedia.org/wiki/Связный_список#Двусвязный_список_(двунаправленный_связный_список)). <kbd>middle</kbd>
     > Эти структуры данных часто используются в разработке так как являются самым простым способом связать элементы с собой.
     > Они так же активно используются внутри вашего языка (под "капотом") повсеместно.
1. Форматы хранения и передачи данных
   * Текстовые. <kbd>junior</kbd>
     > Текстовые форматы используются так же для хранения конфигурации приложений
     * JSON
     * YAML
     * XML
   * Бинарные. <kbd>middle</kbd>
     > Бинарные форматы используются сугубо для хранения и передачи данных.
     * MessagePack
     * BSON (бинарный аналог JSON)
     * ProtoBuf

# Этап 4. Сеть

Сеть в разработке самая важная и, часто, мало заметная часть.

1. Базовое понимание работы сети. <kbd>junior</kbd>
   * Протокол TCP <kbd>middle</kbd>
     > Вы вряд ли будете читать пакеты TCP. Но полезно знать КАК работает TCP,
     > это позволит понять почему при идеальных "интернетах" всё равно приложение может лагать по сети.
     * TCP пакет <kbd>guru ⚡</kbd>
       > Врят-ли придётся работать с пакетом TCP напрямую, однако из его стуктуры можно подчерпнуть некоторую полезную информацию по протоколу TCP вцелом.
     * Флаги ACK, SYN, FIN и прочие <kbd>middle+</kbd>
       > Флаги отвечают за организацию, подтверждение передачи и закрытие TCP коннектов.
     * Буферы (window size) <kbd>middle</kbd>
     * [Проблемы TCP](https://www.youtube.com/watch?v=aXYJlizk3CQ) <kbd>middle+</kbd>
       > TCP очень старый протокол, который уже не удовлетворяет современным реалиям.
   * Протокол UDP. <kbd>middle</kbd>
     > Самый простой сетевой протокол семейства. Требуется понимание его работы.
     > HTTP/3.0, DNS работает на протоколе UDP, и понимание UDP даст немного понимания в работе HTTP/3.0
     * UDP-пакет <kbd>guru ⚡</kbd>
       > Изучить придётся только если потребуется создать свой протокол передачи данных взамен изжившего себя TCP.
1. Проблемы сети. <kbd>junior</kbd>
   > Их, как всегда, много. Но стоит выделить те, которые явно влияют на скорость работы сети.
   > По большей части эти проблемы присущи TCP, но могут появиться и там где эмулируют TCP — на другом протоколе (например UDP)
   * Packet loss <kbd>junior</kbd>
   * Reordering <kbd>middle</kbd>
   * Jitter <kbd>middle</kbd>
   * Round-Trip Time (RTT aka лаг) <kbd>junior</kbd>
   * [Сетевое ожидание](https://developer.mozilla.org/ru/docs/Web/Performance/Understanding_latency) (Network latency, задержка) <kbd>middle</kbd>
1. IPv4, IPv6.
   > Базовое отличие протоколов надо знать, хотя бы, что бы правильно создать колонку IP в базе и обработку в коде.
1. [DNS](https://developer.mozilla.org/ru/docs/Learn/Understanding_domain_names). <kbd>junior</kbd>
   > Ваш код 24/7 будет работать с доменами так как никто не использует чистый IP для соединения с чем-либо.
   > Зная как работает DNS и управление резолвингом домена в системе, можно упростить отладку в некоторых случаях.
   * [Как работает резолвинг доменов](https://temoto.github.io/a/kak-rabotayut-domeny.html) <kbd>junior</kbd>
   * [DNS записи](https://ru.wikipedia.org/wiki/Типы_ресурсных_записей_DNS) <kbd>middle</kbd>
     * Основные MX, CNAME, NS, A, AAAA, TXT <kbd>middle</kbd>
     * Прочие записи <kbd>middle+</kbd>
   * Файл `/etc/hosts` <kbd>junior</kbd>
     > Самый простой и доступный способ поменять IP любому домену, локально, конечно же.
   * Файл `/etc/resolv.conf` <kbd>middle+</kbd>
     > Конфигурация для системы, как и где надо резолвить домены.
   * Консольные команды работы с доменами: `whois`, `dig`, `host`. <kbd>junior</kbd>
     > Что бы идентифицировать проблему с доменом нужно научиться работать с этими командами. 
     > Анализируйте домены как через дефолтный для себя DNS так и через публичные, такие как `1.1.1.1` или `8.8.8.8`.
1. Трассировки маршрутов. <kbd>middle</kbd>
1. Анализ трафика через `tcpdump` + `wireshark` <kbd>guru ⚡</kbd>
   > Не простой, но очень эффективный способ "увидеть" и проанализировать трафик в удобном UI.
1. [Упороться сетью полностью](https://hpbn.co/) <kbd>guru ⚡</kbd>

# Этап 5. Базы данных

Без баз данных — никуда. Самый частый вид баз данных — реляционные базы данных.
Поэтому даже <kbd>junior</kbd> должен уметь работать с ними,
а вот с NoSQL базами данных можно ознакомиться чуть позже.

1. Реляционные базы данных MySQL/Postgres/итд. <kbd>junior</kbd>
   > MySQL подразумевает как MySQL от Oracle, так и различные варианты в виде MariaDB, Percona XTraDB и т.д.
   > В общем понимании семейства: MySQL/Postgres/MSSQL/и т.д. имеют схожие SQL API, различаются только внутренней реализацией, производительностью и масштабируемостью.
   * Базовый синтаксис запросов `SELECT`/`INSERT`/`UPDATE`/`DELETE`. <kbd>junior</kbd>
   * Создание и модификация таблиц <kbd>junior</kbd>
       * Типы колонок таблиц их назначение и различие <kbd>junior</kbd>
           * Целочисленные типы (int)
           * Текстовые типы (text)
           * Наборы, перечисления (enum)
           * Строковые типы (char, varchar)
           * Десятичные типы (decimal)
           * Цисла с плавающей запятой (double)
           * прочие
       * Создание и применение ALTER запросов. <kbd>junior</kbd>
   * Анализ выполнения запросов через `EXPLAIN`, понимание результатов `EXPLAIN`. <kbd>junior</kbd>
     > Самый действенный способ понять почему тормозит запрос.
   * Диагностика производительности.
     > Всегда будут появляться медленные запорсы, и чем их больше тем медленее будет работать ваше приложение.
     > И как правило у разных баз данных всегда есть аналитика для поиска "узких" мест.
      * Ведение логов медленных запросов — slow_log. <kbd>middle</kbd>
        > Не получится сидеть всё время, мониторя все запросы. Проще настроить агрегацию медленных запросов.
      * Чтение аналитики и статистики <kbd>middle+</kbd>
        > В MySQL семействе это perfomance_scheme, в postgres это Statistics Collector. 
        > Поможет в полной мере понять какие запросы плохо работают, где не достаёт индексов, где их в избытке и так далее.
   * Индексы <kbd>junior</kbd>
     > Индексы очень важная часть баз данных. Ваши запросы всегда должны работать "по индексам".
     > Запрос без индекса или с "плохим" индексом, на нагруженных проектах, гарантировано может привести к падению приложения.
     * Кластерный индекс <kbd>middle</kbd>
       > Это не относится к вычислительным кластерам. Это индекс данных, по нему и укладываются строки в таблице.
     * PRIMARY индекс (aka первичный индекс) <kbd>junior</kbd>
       > Индекс, уникально идентифицирующий каждую строчку в таблице. Как правило, PRIMARY индекс и есть кластерный индекс.
     * UNIQUE/обычнык индексы <kbd>junior</kbd>
     * Составные индексы. <kbd>junior</kbd>
       > Условия и/или сортировки редко когда бывают по одному полю, обычно их больше. Вот тут на сцену выходят составные индексы.
       > Тут надо понимать что в составном индексе, последовательность полей важна.
       * Понимание какие поля в какой последовательности добавлять в индекс при фильтрации и/или сортировке. <kbd>middle</kbd>
       * Понимание как строятся деревья индексов у составных индексов. <kbd>middle+</kbd>
     * [Понимание работы индексов](https://ruhighload.com/Индексы+в+mysql) <kbd>middle</kbd>
     * Алгоритм построения индексов `BTREE`. <kbd>guru ⚡</kbd>
       > Это понимание не сделает ваши запросы быстрее, но даст понятие как ведут себя те или иные данные в индексах.
     * Объединение таблиц `LEFT JOIN`, `RIGHT JOIN`, `INNER JOIN`, `OUTER JOIN`, `JOIN`. <kbd>junior</kbd>
       > Данные всегда "размазаны" по таблицам. Что бы их собрать потребуются эти операторы.
     * Группировка данных через `GROUP BY`. <kbd>junior</kbd>
       > Группировка данных — не редкие запросы, как правило, используются для сбора статистики.
       * Фильтрация после группировки. <kbd>junior</kbd>
       * Функции работы с группами MAX/MIN/AVG/итд <kbd>junior</kbd>
     * Понимание и назначение внешних ключей (`foreign key`) <kbd>middle</kbd>
       > Нередко используют внешние ключи для поддержания консистентности данных в базе.
     * Транзакции. <kbd>middle</kbd>
       > Что бы провести несколько операций атомарно (как одну операцию) используются транзакции.
       * Уровни изоляций транзакций. <kbd>middle</kbd>
       * Deadlock и как его не допускать. <kbd>middle+</kbd>
     * Триггеры на `INSERT`/`UPDATE`/`DELETE`. <kbd>middle</kbd>
       > Не стоит активно использовать триггеры.
       > Тем не менее они могут оказаться полезными в некоторых отладочных или maintenance случаях.
     * Хранение деревьев. <kbd>junior</kbd>
       > Не просто сохранить древовидную структуру в реляционной базе. Есть насколько алгоритмов со своими плюсами и минусами.
       > На самом деле актуально и для других видов баз данных
       * Алгоритм parent-child <kbd>junior</kbd>
         > Классический вариант "с parent_id" у дочерних элементов. Простые и "дешевые" на вставку элементов в деревья.
         > Но такие деревья затратные "на сборку".
       * Алгоритм [nested sets](https://devacademy.ru/article/nested-set) <kbd>middle</kbd>
         > Алгоритм позволяет достаточно дёшево собирать деревья с различными модификациями и сегментами.
         > Но затратные на вставку элементов в деревья.
1. Документо-ориентированная база данных (часть NoSQL баз данных) — MongoDB. <kbd>middle</kbd>
   > Среди всех NoSQL самой популярной является MongoDB.
   * Типы данных в коллекциях, их назначение и различия. <kbd>middle</kbd>
   * Анализ выполнения запросов через `explain()`, понимание его результатов. <kbd>middle</kbd>
   * Понимание работы индексов (аналогично SQL индексам с небольшими отличиями). <kbd>middle</kbd>
     * Sparse свойство индекса
     * Partial свойство индекса
     * TTL свойство индекса
     * Geospatial индекс
     * Text индекс
   * Вложенные объекты, массивы. <kbd>middle</kbd>
   * Агрегации <kbd>middle+</kbd>
   * Работа с репликацией. <kbd>middle+</kbd>
   * Работа с кластером MongoDb. <kbd>middle+</kbd>
1. Redis <kbd>junior</kbd>
   > Универсальный инструмент хранения данных с уклоном в производительность.
   > Может быть, как быстрым постоянным хранилищем, так и реактивным кэширующим, временным хранилищем.
   * [базовая работа с ключами](https://redis.io/commands#generic) :us: <kbd>junior</kbd>
   * [работа со списками](https://redis.io/commands#list) :us: <kbd>junior</kbd>
   * [работа с хешами](https://redis.io/commands#hash) :us: <kbd>junior</kbd>
   * [работа с набором](https://redis.io/commands#set) :us: <kbd>junior</kbd>
   * [сортированным набором](https://redis.io/commands#sorted_set) :us: <kbd>middle</kbd>
   * [Транзакции](https://redis.io/topics/transactions) :us:, но в другом, своём, понимании.
   * [Работа с Lua](https://redis.io/commands/eval) :us: <kbd>middle</kbd>
     > Даёт возможность запустить любой набор команд атомарно, дополнительно снабдив логикой.
1. Проблемы в базах данных <kbd>junior</kbd>
   * Deadlock <kbd>middle</kbd>
   * Переполнение числовых полей (в том числе autoincrement) <kbd>junior</kbd>
   * Full scan <kbd>middle</kbd>
   * Split-brain <kbd>middle+</kbd>

# Этап 6. Протокол HTTP

Каждый WEB разработчик должен понимать протокол HTTP.
Разработчик который не знает HTTP протокол — это как сапожник без сапог.
Поэтому даже <kbd>junior</kbd> должен многое знать про протокол HTTP.

1. [Понимание общего формата протокола](https://developer.mozilla.org/ru/docs/Web/HTTP/Overview): где заголовки, а где тело. <kbd>junior</kbd>
1. Сродниться со вкладкой Сеть/Network в инспекторе браузера <kbd>junior</kbd>
   > В консоли можно наблюдать все HTTP-запросы со страницы и даже делать самим через функцию `fetch`.
1. [Методы HTTP-запросов.](https://developer.mozilla.org/ru/docs/Web/HTTP/Methods) Их назначение и ограничения. <kbd>junior</kbd>
   > Каждый метод имеет своё назначение (достаточно перевести названия методов) и, как следствие, имеет свои условности и ограничения.
   * Основные [GET](https://developer.mozilla.org/ru/docs/Web/HTTP/Methods/GET), [POST](https://developer.mozilla.org/ru/docs/Web/HTTP/Methods/POST), [HEAD](https://developer.mozilla.org/ru/docs/Web/HTTP/Methods/HEAD) <kbd>junior</kbd>
   * Дополнительные `PUT`, `DELETE`, `PATCH` <kbd>middle</kbd>
     > Используюся в REST API вместе с основными методами
   * Прочие <kbd>middle+</kbd>
     > Это уже методы узкой направленности, редко когда придётся с ними напрямую работать. Тем не менее они активно используются приложениями.
1. [Коды HTTP ответов](https://developer.mozilla.org/ru/docs/Web/HTTP/Status) <kbd>junior</kbd>
   * Принцип разделения кодов на группы: 100-199, 200-299, 300-399, 400-499, 500-599. <kbd>junior</kbd>
     > Коды создавались и описывались не в хаотичном порядке. Есть чёткое разделение их "сфер влияния".
     > Даже если какой-то сервер придумает свой код ответа, то по группе вы сможете лучше понять причину такого ответа.
   * Основные (частые): [200](https://developer.mozilla.org/ru/docs/Web/HTTP/Status/200),
     [206](https://developer.mozilla.org/ru/docs/Web/HTTP/Status/206),
     [301](https://developer.mozilla.org/ru/docs/Web/HTTP/Status/301),
     [302](https://developer.mozilla.org/ru/docs/Web/HTTP/Status/302),
     [304](https://developer.mozilla.org/ru/docs/Web/HTTP/Status/304),
     [400](https://developer.mozilla.org/ru/docs/Web/HTTP/Status/400),
     [401](https://developer.mozilla.org/ru/docs/Web/HTTP/Status/401),
     [403](https://developer.mozilla.org/ru/docs/Web/HTTP/Status/403),
     [404](https://developer.mozilla.org/ru/docs/Web/HTTP/Status/404),
     [500](https://developer.mozilla.org/ru/docs/Web/HTTP/Status/500),
     [502](https://developer.mozilla.org/ru/docs/Web/HTTP/Status/502),
     [503](https://developer.mozilla.org/ru/docs/Web/HTTP/Status/503),
     [504](https://developer.mozilla.org/ru/docs/Web/HTTP/Status/504) <kbd>junior</kbd>
     > Это наиболее частые коды ответов которые вы гарантировано встретите.
   * [Другие](https://developer.mozilla.org/ru/docs/Web/HTTP/Status) <kbd>middle</kbd>
1. [Заголовки HTTP](https://developer.mozilla.org/ru/docs/Web/HTTP/Заголовки) <kbd>junior</kbd>
   * [MIME тип](https://developer.mozilla.org/ru/docs/Web/HTTP/Basics_of_HTTP/MIME_types) (тип документа) и заголовок типа [Content-Type](https://developer.mozilla.org/ru/docs/Web/HTTP/Заголовки/Content-Type). <kbd>junior</kbd>
     * Формат передачи `application/x-www-form-urlencoded` <kbd>junior</kbd>
     * Формат передачи [multipart/form-data](https://ru.wikipedia.org/wiki/Multipart/form-data) <kbd>middle</kbd>
   * Системные заголовки Host, Content-Length,
     [Content-Encoding](https://developer.mozilla.org/ru/docs/Web/HTTP/Headers/Content-Encoding),
     [Transfer-Encoding](https://developer.mozilla.org/ru/docs/Web/HTTP/Headers/Transfer-Encoding)) <kbd>junior</kbd>
   * [Кэширование HTTP](https://developer.mozilla.org/ru/docs/Web/HTTP/Кэширование), заголовки управления кэшем: `Cache-Control`, `Expires`, `Vary`, `ETag`, `Last-Modified`.
1. [Куки](https://developer.mozilla.org/ru/docs/Web/HTTP/%D0%9A%D1%83%D0%BA%D0%B8) <kbd>junior</kbd>
   > На данный момент это единственный точный способ идентифицировать пользователя.
1. [Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/ru/docs/Web/HTTP/CORS) <kbd>middle</kbd>
   > Для кросс-доменных XHR/WebSocket запросов надо научиться работать с CORS, иначе запросы не будут работать.
1. [Content-Security-Policy (CSP)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy) <kbd>middle</kbd>
   > Для повышения безопасности можно ограничить и указать что и откуда может загружаться и запускаться на странице.
1. Различия версий протокола HTTP: HTTP/1.0, HTTP/1.1 <kbd>middle</kbd>
   > Не смотря на появление новых версий протокола HTTP, версии HTTP/1.0 и HTTP/1.1 всё еще остаются частыми во внутренних сетях кластеров.
1. Консольные команды HTTP запросов `curl`, `wget` <kbd>junior</kbd>
   > На серверах (хостах) нет браузеров, чью удобную консоль можно использовать.
   > Там есть shell и множество утилит, которые умеют работать с HTTP.
1. Различия протоколов HTTP/1.1, HTTP/2.0 и HTTP/3.0 <kbd>middle+</kbd>
   > Каждый протокол имеет свои возможности и улучшения, которые можно использовать для ускорения приложения.
1. WebSocket протокол <kbd>middle</kbd>
   > Это расширения версии HTTP/1.1 и выше для механизма обмена данными по одному соединению.
   > Часто используется для чатов и/или для event-driven модели.
1. WebRTC <kbd>guru ⚡</kbd>
   > Если надо будет организовывать P2P (peer-to-peer) чаты или P2P стриминг, то WebRTC как раз для этого.
1. HTTP API форматы <kbd>junior</kbd>
   * [REST API](https://ru.wikipedia.org/wiki/REST) <kbd>junior</kbd>
   * RPC <kbd>junior</kbd>
   * [GraphQL](https://habr.com/ru/post/326986/) <kbd>middle</kbd>
1. Web сервера <kbd>junior</kbd>
   * [Nginx](https://nginx.org). <kbd>junior</kbd>
     > Самый распространённый Web-сервер. Вероятность натолкнуться на него во время разработки web-приложения - высока.
     * [Ознакомление с базовыми возможностями](https://nginx.org/ru/docs/beginners_guide.html) <kbd>junior</kbd>
     * [Масштабируемая конфигурация nginx](https://www.youtube.com/watch?v=jf3wIN-FwW4) <kbd>middle</kbd>
     * Написание простых локаций в `/etc/nginx/nginx.conf` раздачи файлов <kbd>junior</kbd>
     * HTTP, FastCGI проксирование <kbd>junior</kbd>
   * [Apache httpd](https://httpd.apache.org/). <kbd>junior</kbd>
     > Один из старых, но активно использющихся Web-серверов широкого профиля. 
     > Хоть он уже и уступает nginx-у в популярности, но столкнуться с ним в проекта есть всё так же легко. 

# Этап 7. Безопасность

Ваше приложение всегда под угрозой, даже если это какое-то home-page приложение.
Ботнетам всегда не хватает вычислительных ресурсов. Хакерам — данных. А пользователям — мозгов (без обид).

1. Виды управления доступом <kbd>middle</kbd>
   * Access Control List (ACL) <kbd>middle</kbd>
   * [Role-based access control](https://habr.com/ru/company/custis/blog/248649/) (RBAC) <kbd>middle</kbd>
   * [Attribute-based access control](https://habr.com/ru/company/custis/blog/248649/) (ABAC) <kbd>middle</kbd>
1. Аутентификация <kbd>junior</kbd>
   * [Basic](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication) <kbd>junior</kbd>
     > Самый простой вид авторизации, не требующий дополнительных вычислительных мощностей (серверов).
   * [SSO](https://habr.com/ru/company/nixys/blog/563244/) (Single Sign On) <kbd>junior</kbd>
     > Общее название подхода к авторизации: авторизация на множестве приложений через одну точку. OAuth и OpenID — частные случаи SSO.
   * [OAuth2](https://www.digitalocean.com/community/tutorials/oauth-2-ru) <kbd>middle</kbd>
     > Распространенный вид авторизации через посредника, который гарантирует что Вы это Вы и может выдать некоторые данные по пользователю, с его согласия.
     > Часто сталкиваются c OAuth2 тогда когда надо подключить авторизацию через соц. сети. У них у всех OAuth2 (но каждый со своими модификациями).
   * OpenID <kbd>middle</kbd>
     > Один из первых популярных SSO. Уступает Oauth2 по популярности, но так же где-то используется.
   * Ldap <kbd>middle</kbd>
     > Данный вид авторизации используется, чаще всего, для авторизации во внутренних сервисах своих сотрудников.
   * JSON Web Token (JWT) <kbd>middle</kbd>
     > Это не тип авторизации, а инструмент для передачи идентифицирующих данных. Однако такой токен может иметь очень широкое применение, не только в авторизации.
1. [Виды атак и уязвимостей](https://docs.wallarm.ru/attacks-vulns-list/) <kbd>junior</kbd>
   * Фишинг сайта <kbd>junior</kbd>
   * Небезопасное перенаправление, Open Redirect <kbd>junior</kbd>
   * Инъекции (например SQL-инъекции) <kbd>junior</kbd>
   * XSS атака <kbd>junior</kbd>
   * IDOR уязвимость <kbd>middle</kbd>
   * CRLF атака <kbd>junior</kbd>
   * LFI/RFI атака <kbd>junior</kbd>
   * DoS/DDoS <kbd>middle</kbd>
     * HTTP-флуд <kbd>middle</kbd>
     * SYN flood (потребуются знания TCP) <kbd>middle+</kbd>
     * UDP flood (UDP амплификация) <kbd>middle+</kbd>
     * Медленный запрос <kbd>middle</kbd>
   * Бомбы <kbd>middle</kbd>
      * Logic Bomb <kbd>middle</kbd>
      * Zip Bomb <kbd>junior</kbd>
   * Атака посредника (Man In The Middle, MITM) <kbd>middle</kbd>
   * Брутфорс (например брутфорс паролей) <kbd>junior</kbd>
   * Спуфинг <kbd>middle</kbd>

# Этап 8. Тут должен быть ваш язык программирования

Языков программирования много. Однако, они имеют много общего между собой, кто-то больше, а кто-то меньше.
Этот этап будет задевать только часто встречающиеся пункты в большинстве популярных языков программирования.
Этап не будет чётко дробиться на градации, так как многое зависит от самого языка, его возможностей и его расширений.

Принцип работы с этим разделом: ищите `%ваш_язык_программирования% %пункт_из_этапа%`.
Учтите, что **некоторых пунктов может не быть в вашем языке**.

1. Что такое интерпретатор, компилятор, JIT, оп-код, байт-код. Что из этого использует ваш язык? <kbd>junior</kbd>
1. Ваш язык программирования <kbd>junior</kbd>
   * Примитивные типы данных 
     > Базовые скалярные типы — целые числа, строки, бeлевы значения, числа с плавующей точкой, null/nil и так далее.
   * Функции
     * Определение и их вызов
       > Умение определить простую функцию и вызвать её. Бывают языки где функций без объектов не может быть
     * Главная функция или точка входа в программу.
       > В языке программа может запусткаться только через стартовую функцию, например `main()`. 
       > Но некоторые языки позволяют запустить файл с кодом.
   * Набор, массив, хеш-таблица (ассоциативный массив), кортеж.
     > Представляет собой различные комбинации примитивных типов. Например числовой массив данных можно сделать почти в любом языке.
   * Объекты/классы/структуры, прототипы/интерфейсы/миксины.
     > Все современные языки имеют объекты и умеют ими оперировать. 
     * Перегрузка операторов
       > Позволяет объектам самим определять как над ними производить математические, логические и прочие действия (операции).
     * Перегрузка методов
       > Позволяет определить несколько методов с одним названием, но с разной сигнатурой.
       > Как правило это достигается за счет различного набора параметров (количества или типов принимаемых значений) для каждого метода.
     * Generics (aka генерики aka шаблоны aka обобщения)
       > Специфичная возможность некоторых языков программирования со строгой типизацией. 
       > Позволяет определить единую сигнатуру для обработки различных типов.
     * Объектно-ориентированное программирование (ООП)
   * Ссылки, слабые ссылки.
   * Области видимости переменной.
     > Важно понимать когда ваши переменные доступны в когде, а где уже/ещё нет. Особенно важно это понимать когда работаете с ссылками в переменных.
   * Garbage Collector (GC).
     > Много языков высокого (и не только) уровня имеют GC. GC отвечает за особождение памяти от мусора (забытые данные, данные которые уже не нужны коду) 
     > в процессе работы кода. Это очень важная часть вашего языка, так как пока работает GC — не работает ваш код. 
     > А если GC будет часто и/или много работать то ваше приложение начнет лагать и "зависать".
     * Когда и как запускается GC.
     * Изучить настройки GC.
     * Включение/выключение GC, принудительный запуск GC.
     * Профилирование утечек или потребления памяти.
   * Преобразование типов.
   * Слабая/сильная типизация в коде. На что влияет и как с этим жить.
     > Сильная типизация требует явного указания в коде типа данных, которые будут использоваться в переменной, аргументе и т.д. 
     > А динамическая, наоборот, позволяет не указывать тип. Вычисление типа значения будет происходить динамически, в момент выполнения программы/программного кода (runtime). 
     > Некоторые языки могут поддерживать одновременно как строгую так и слабую типизации.
   * Битовые операции: `not`, `and`, `or`, `xor`, сдвиг влево, сдвиг вправо <kbd>junior</kbd>
     > Часто вместо `or` и `and` используются символы `|`/`||` и `&`/`&&`.
     > С битовыми операциями можно столкнуться чаще чем кажется, много функций/методов принимают опции в виде битовых флагов вида `READ|WRITE|CREATE`.
     > Нужно уметь комбинировать битовые флаги, удалять, определять какие флаги установлены. 
   * Обработка ошибок. Исключения, паники, error и прочие проявления _ошибок_.
   * Проблемы в коде
     * Бесконечные циклы
     * Рекурсии
     * Погрешность в числах с плавующей запятой (float, double, number).
     * Ошибка сегментации (и ее связь с сигналом SIGSEGV)
1. Распараллеливание <kbd>middle</kbd>
   * Процессы
     * Создание дочернего процесса через [fork](https://ru.wikipedia.org/wiki/Fork).
     * Поведение дескрипторов до и после fork.
     * Разделяемая память (Shared memory)
     * Межпроцессное взаимодействие (IPC)
   * Потоки (threads)
     > В отличии от процессов, потоки имеют общую память, как следствие, всегда единую кодовую базу.
     * Истинные потоки (pthreads, posix-threads)
     * Зелёные потоки (Green threads)
       > Ведут себя как истинные потоки, но таковыми не являются, так как только эмулируют распараллеливание.
   * КоРутины
     > Вариант распарелливания, когда один код приложения, ожидающий событие системы, уступает CPU другому коду приложения. 
     > Выполняются-ли они параллельно - зависит от реализации.
   * Проблемы распараллеливания
     * Race Condition (aka race)
   * Атомарные операции
     > При работе в потоках, для избежания Race, языки реализовывают атомарные операция, позволяющие безопасно менять значения переменным.
   * Блокировки 
     > Что бы избегать Race нужно использовать блокировки.
     * Mutex (aka Мьютекс / aka mutual exclusion)
       > По сути это атомарная блокировка.
     * Семафоры
       > Упрощенный вид mutex
1. Пакетный менеджер или менеджер зависимостей. <kbd>junior</kbd>
1. Расширения языка
   > Высокоуровневые языки, обычно, расширяются модулями, написанными на низкоуровневом языке, на котором написан сам обработчик языка.
1. Отладчик (aka дебаггер)
   > Большую часть времени вы будете не писать новый код, а производить отладку уже написанного кода. 
   > В некоторых языках отладчик уже "встроен в язык", но некоторые языки требуют дополнительные модули или инструменты для этого.
1. Запуск сервера и работа c ним в языке (обработка HTTP-запросов). <kbd>junior</kbd>
   > Некоторые языки в коде запусают сервера, а некоторые имеют отдельный сервер который запускает код. Может быть и то и то.
1. Кэширование данных <kbd>middle</kbd>
   * Частые алгоритмы кэша [LRU](https://ru.wikipedia.org/wiki/Алгоритмы_кэширования#Least_recently_used_(Вытеснение_давно_неиспользуемых)), LFU
   * [Иные алгоритмы кэширования](https://ru.wikipedia.org/wiki/Алгоритмы_кэширования) <kbd>guru ⚡</kbd>
   * Прогревание кэша, инвалидация кэша
1. Шаблонизация
   > Генерировать UI через `print`'ы очень плохая практика из-за множества проблем с поддержкой такого кода, с ростом проекта и контрибуторов.
   > В вашем языке должны быть пакеты/модули для шаблонизации. И, как правило, их несколько.
1. Юнит тестирование <kbd>junior</kbd>
   > Ознакомление с системой тестирования в вашем языке. Подбор пакета/модуля для тестирования.
1. Специфика работы IO (сокетов, дескрипторов, потоков) <kbd>middle</kbd>
   * Буферы IO
   * Асинхронный IO

# Этап 9. Электронная почта

Работа с email, неотъемлемая часть web-разработки (да и не только). По факту, это едиственный гарантированный канал связи с пользователем.

1. [Спецификация письма MIME](https://www.opennet.ru/docs/RUS/inet_server/servers_glava2_5.html) <kbd>junior</kbd>
   * Основные заголовки: `Return-Path`, `Received`, `From`, `To`, `Cc`, `Bcc`, `Reply-To`, `Subject`, `Message-ID` <kbd>junior</kbd>
   * прочие заголовки <kbd>middle+</kbd>
   * указание кодировки <kbd>junior</kbd>
   * кодирование полей и тела в base64 и qp (quoted-printable) <kbd>middle</kbd>
1. Установка [MailHog](https://github.com/mailhog/MailHog) <kbd>middle</kbd>
   > Это почтовый сервер для тестирования работы отправки писем приложениями, который можно поднять локально в контейнере.

# Этап 10. Полнотекстовый поиск

Каждый разработчик сталкивается с необходимостью полнотекстового поиска, да и в целом быстрого поиска по куче аттрибутов и текстов.
Для этого используются различные полнотекстовые поисковые движки такие как [ElasticSearch](https://www.elastic.co/), [SphinxSearch](http://sphinxsearch.com/), [ManticoreSearch](https://manticoresearch.com/), [MeiliSearch](https://www.meilisearch.com/) и тд.
Самый распространенный полнотекстовый поисковый движок с большим сообществом — ElasticSearch.

1. Установить [Cerebro](https://github.com/lmenezes/cerebro) для работы с ElasticSearch. <kbd>junior</kbd>
1. Индексы <kbd>junior</kbd>
   * Alias <kbd>middle</kbd>
   * Настройки <kbd>middle+</kbd>
   * Шаблоны <kbd>middle</kbd>
   * Mapping <kbd>middle</kbd>
1. Запросы <kbd>junior</kbd>
   * Запросы поиска <kbd>junior</kbd>
   * Запросы добавления/обновления/удаления документов <kbd>junior</kbd>
   * bulk запросы <kbd>middle</kbd>
     > Запросы на изменение лучше делать пачкой, так называемым bulk-ом.
   * painless-скриптинг <kbd>middle</kbd>
     > потребуется что бы точечно обновить некоторые поля у документа или вложенные документы, вместо всего документа
1. Подключение или изменение морфологий <kbd>junior</kbd>
1. Агрегации <kbd>middle+</kbd>
1. Lucene индексы <kbd>middle+</kbd>
   > Основную работу по индексации и поиску выполняют Lucene-индексы. Сам ElasticSearch — кластер с HTTP-сервером, 
   > гарантирующий сохранность Lucene-индексов и отвечающий за их репликацию и шардирование.
   > Если вам нужно что бы была быстрая индексация и/или быстрый поиск то вам надо тюнить работу Lucene-индексов.

# Этап 11. Логи и метрики

Метрики позволят узнать о проблеме, а логи позволят понять причину проблемы. Для крупных и/или распределённых систем этот тандем обязателен.
Для обработки большого объёма данных нужны подходящие системы для сбора, хранения и агрегации.
Любое приложение должно уметь генерировать _полезные_ метрики для системы сбора и анализа метрик. И писать _правильные_ системные логи о _своих_ событиях. 
Логи о событиях пользователей уже относятся к аудиту, а не к системным логам.

1. Системы хранения и обработки логов
   > Их на самом деле много, но среди бесплатных opensource, по популярности выделяются несколько
   * Решение [ELK](https://www.elastic.co/what-is/elk-stack) <kbd>middle+</kbd>
     > Не самая тривиальная, но эффективная для приёма, обработки, хранения и работы с логами.
     > ELK: Logstash - парсит логи, ElasticSearch - хранит логи, Kibana - UI для ElasticSearch для работы с логами.
   * [ClickHouse](https://clickhouse.tech/docs/ru/) <kbd>middle+</kbd>
     > Колоночная база данных, которая отлично справляется с большим количеством логов (и не только access). Если проводить аналогию с ELK то:
     > MaterializedView - позволяет парсить (структурированные) логи, семейство MergeTree — хранит логи.
     > А вот UI только сторонний брать, например Grafana или [Kibana](https://www.highload.ru/moscow/2019/abstracts/5906).
1. [Prometheus](https://prometheus.io/) или подобные, например, [Victoria Metrics](https://victoriametrics.com/) <kbd>middle</kbd>
   > Популярная система сбора и хранения метрик.
   * Типы метрик <kbd>middle</kbd>
     * count
     * gauge
     * histogram
     * summary
   * Варианты отправки метрик: push и pull <kbd>middle</kbd>
   * Запросы (лучше и наглядней делать из Grafana) <kbd>middle</kbd>
     * [Синтаксис](https://prometheus.io/docs/prometheus/latest/querying/basics/) <kbd>middle</kbd>
     * Лейблы
     * Векторы
     * Интервалы
     * Операторы
   * [Функции](https://prometheus.io/docs/prometheus/latest/querying/functions/), особенно стоит выделить 2 из них: <kbd>middle</kbd>
     * rate
     * irate
1. Grafana <kbd>middle+</kbd>
   > Отличный UI для отображения метрик из разных систем хранения, включая Prometheus-like системы.
   * Создание дашбордов
   * Создание графиков
   * Настройка алертов

# Этап 12. Проектирование и разработка

Паттерны, концепции и подходы к проектированию различных web-приложений.

1. Принципы разработки <kbd>junior</kbd>
   * GRASP (General Responsibility Assignment Software Patterns) <kbd>middle</kbd>
   * [SOLID](https://blog.byndyu.ru/2009/10/solid.html) (Single Responsibility, Open–Closed, Liskov Substitution, Interface Segregation, Dependency Inversion) <kbd>middle</kbd>
   * KISS (Keep It Simple, Stupid) <kbd>junior</kbd>
   * YAGNI (You Aren't Gonna Need It) <kbd>junior</kbd>
   * DRY (Don’t Repeat Yourself) <kbd>junior</kbd>
   * [IoC](https://habr.com/ru/post/321344/) (Inversion Of Control), и как следствие — DI (Dependency Injection) <kbd>middle</kbd>
   * DDD (Domain-Driven Design) <kbd>middle</kbd>
1. Архитектурные шаблоны <kbd>junior</kbd>
   > В одном проекте может быть один или несколько архитектурных шаблонов, или даже половина. Архитектурные шаблоны - подход к решению задачи, которую возложили на проект.
   * Гексагональная архитектура <kbd>middle+</kbd>
   * [Event-Driven Architecture](https://habr.com/ru/post/346630/) (aka Шаблон посредника или Broker pattern) <kbd>middle+</kbd>
   * Onion Architecture (аkа Луковая архитектура или Многоуровневый шаблон) <kbd>middle+</kbd>
   * CQRS (The Command and Query Responsibility Segregation) <kbd>middle+</kbd>
   * SoA (Service-Oriented Architecture) <kbd>middle+</kbd>
   * Event Sourcing <kbd>middle+</kbd>
   * Шаблон MVC <kbd>junior</kbd>
     > Самый старый и достаточно распространённый шаблон проектирования приложения, разделяющий UI от логики приложения.
   * [Шаблон ADR](https://habr.com/ru/post/260769/) (Action-Domain-Responder)
     > Доработка MVC под задачи веба
   * Шаблон MVP <kbd>junior</kbd>
     > MVP - итерация развития MVC из-за усложнений приложений и UI. Часто используется во front-end - в браузере.
   * Шаблон [MVVM](https://habr.com/ru/company/mobileup/blog/313538/)
     > На самом деле этот шаблон подходит для десктопных или мобильных приложений. В web приложениях практически не используется.
1. [Шаблоны проектирования](https://refactoring.guru/ru/design-patterns/examples)
   > Шаблоны упрощают разработку, так как это, по сути, опыт сообщества по решению тех или иных проблем. 
   > Главное не забывайте про KISS и YAGNI что бы не упасть в ад абстракций и пучину сложости.
   * Порождающие шаблоны проектирования
   * Структурные шаблоны проектирования
   * Поведенческие шаблоны проектирования
1. Методологии разработки
   > Это не про scrum, agile, waterfall, планирование, проектирование и прочее. Это про методологии написания кода.
   * [TDD](https://habr.com/ru/company/ruvds/blog/450316/) (Test Driven Development)
     > Разработка через тестирование, самый известный способ разработки, требующий от разработчика сначала - написание теста к коду, а потом самого кода.
   * BDD (Behavior Driven Development)
     > Расширенная версия TDD, тем что сначало пишется не тест, а описание что нужно сделать, на предметном языке, например Gherken.
1. [Типы приложения](https://dou.ua/forums/topic/31720/)
   > Существует разделение приложения по способу генерации UI.
   * MPA (Multi-Page Application)
     > Классический тип приложения, с несколькими страницами генерируемыми на back-end для создания UI.
   * SPA (Single Page Application)
     > Общее название типа приложения когда приложение живёт в браузере и ходит за данными на сервер. Может быть как SSG, SSR, CSR или любое их сочетание.
   * SSG (Static Site Generation)
     > Все страницы приложения заранее генерируются в статичные файлы. Динамика полностью на JS. Может быть как и MPA так и SPA.
   * SSR (Server Side Rendering)
     > Подход к генерации страниц приложения. Каждый запрос обрабатывается на сервере, где генерируется UI, а после сервер возвращает ответ клиенту на front-end.
   * CSR (Client Side Rendering)
     > Подход к генерации страниц приложения. Весь UI генерируется в браузере при помощи JS. JS делает запросы на сервера за данными, для построения или изменения UI. 
     > SPA — частный случай CSR.
1. Тестирование. <kbd>junior</kbd>
   * Unit тестирование <kbd>junior</kbd>
     > Тестирование отдельных (в том числе отдельных друг от друга) частей продукта, обычно отдельных функций/методов.
     > Unit-тесты так же несут ещё одну цель - проверка архитектуры вашей реализации.
     > Как правило, если у вас не получается написать unit-тест на функцию/метод, не вовлекая сторонние компоненты приложения
     > то возможно стоит пересмотреть архитектуру. Хорошее Unit-тестирование ведёт к хорошей инверсии котроля (IoC, см. выше)
   * Интеграционные тесты <kbd>middle</kbd>
     > Сложный вид тестов. Проверка работоспособности приложения, модуля, компонентом с другим приложением, модулем, компонентом. 
   * End-to-End (aka E2E aka Сквозное тестирование) <kbd>middle</kbd>
     > Пример E2E теста - тестирование готового API приложения. Тестируются не компоненты приложения, а готовая функциональность.
   * Smoke test (aka дымовые тесты) <kbd>middle</kbd>
     > Дымовые тесты позволяют протестировать саму возможность работать вашему приложению. 
     > Иногда используют для тестирования инфрастуктуры на возможность работать в ней вашему приложению.
1. Проблемы приложений и проектирования. <kbd>junior</kbd>
   * Технический долг. <kbd>junior</kbd>
     > Тех.долг начнёт копиться в проекте с первых строк кода. Всегда стоит его учитывать в разработке и планировать его устранение.
   * Over engineering <kbd>junior</kbd>
     > Когда реализация намного больше или сложнее чем требуется. Потребует кучу ресурсов на поддержку проекта.
   * Преждевременная оптимизация (aka Premature Optimization) <kbd>junior</kbd>
     > Прибегание к оптимизации там где она не требуется на данный момент. Отнимет кучу ресурсов на этапе разработки проекта.
1. [Приёмы рефакторинга](https://refactoring.guru/ru/refactoring/techniques)
   > Что бы изавляться от тех.долга придётся часто и много рефакторить.
1. [Антипаттерны](https://ru.wikipedia.org/wiki/Антипаттерн)
   > Полезно знать как следет делать, но не менее полезно знать как НЕ следует делать.
1. [Semver](https://semver.org/lang/ru/)
   > Самый распространённый принцип наименования версий приложения. В некоторых языках и пакетных менеджерах является обязательным к соблюдению.
1. Распределенные системы
   > Когда приложение упирается в потолок сервера то у вас только один выход - заставить приложение работать на нескольких серверах.
   > Это сильно усложняет приложение и много ресурсов уходит на сохранение целостности и согласованности данных.
   * [Теоремы CAP и PACELC](https://habr.com/ru/company/gaz-is/blog/551986/)
     > В распределённых системах придётся чем-то жертвовать. PACELC - расширенная теорема CAP.
     > Эти теоремы как раз описывают какими параметрами придётся пожертвовать системе.
   * [Микросервисная архитектура](https://dataart.team/ru/news/microservices-kak-pravil-no-delat-i-kogda-primenyat/)
